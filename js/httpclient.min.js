!function (t) { var e = {}; const n = Object.prototype.toString; function r(t) { return function (t, e) { return n.call(t) === `[object ${e}]` }(t, "String") } function s(t) { return t && t.Math == Math ? t : void 0 } const o = "object" == typeof globalThis && s(globalThis) || "object" == typeof window && s(window) || "object" == typeof self && s(self) || "object" == typeof global && s(global) || function () { return this }() || {}; function i() { return o } const c = ["debug", "info", "warn", "error", "log", "assert", "trace"]; function u(t, e, n) { if (!(e in t)) return; const r = t[e], s = n(r); if ("function" == typeof s) try { !function (t, e) { const n = e.prototype || {}; t.prototype = e.prototype = n, function (t, e, n) { Object.defineProperty(t, e, { value: n, writable: !0, configurable: !0 }) }(t, "__sentry_original__", e) }(s, r) } catch (t) { } t[e] = s } !function () { const t = { enable: () => { }, disable: () => { } }; c.forEach((e => { t[e] = () => { } })) }(); const a = i(); function h(t) { return t && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString()) } function f() { if (!function () { if (!("fetch" in a)) return !1; try { return new Headers, new Request("http://www.example.com"), new Response, !0 } catch (t) { return !1 } }()) return !1; if (h(a.fetch)) return !0; let t = !1; const e = a.document; if (e && "function" == typeof e.createElement) try { const n = e.createElement("iframe"); n.hidden = !0, e.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (t = h(n.contentWindow.fetch)), e.head.removeChild(n) } catch (t) { } return t } const d = i(); const l = i(), p = {}, y = {}; function m(t) { if (!y[t]) switch (y[t] = !0, t) { case "console": !function () { if (!("console" in l)) return; c.forEach((function (t) { t in l.console && u(l.console, t, (function (e) { return function (...n) { b("console", { args: n, level: t }), e && e.apply(l.console, n) } })) })) }(); break; case "dom": !function () { if (!("document" in l)) return; const t = b.bind(null, "dom"), e = w(t, !0); l.document.addEventListener("click", e, !1), l.document.addEventListener("keypress", e, !1), ["EventTarget", "Node"].forEach((e => { const n = l[e] && l[e].prototype; n && n.hasOwnProperty && n.hasOwnProperty("addEventListener") && (u(n, "addEventListener", (function (e) { return function (n, r, s) { if ("click" === n || "keypress" == n) try { const r = this, o = r.__sentry_instrumentation_handlers__ = r.__sentry_instrumentation_handlers__ || {}, i = o[n] = o[n] || { refCount: 0 }; if (!i.handler) { const r = w(t); i.handler = r, e.call(this, n, r, s) } i.refCount++ } catch (t) { } return e.call(this, n, r, s) } })), u(n, "removeEventListener", (function (t) { return function (e, n, r) { if ("click" === e || "keypress" == e) try { const n = this, s = n.__sentry_instrumentation_handlers__ || {}, o = s[e]; o && (o.refCount--, o.refCount <= 0 && (t.call(this, e, o.handler, r), o.handler = void 0, delete s[e]), 0 === Object.keys(s).length && delete n.__sentry_instrumentation_handlers__) } catch (t) { } return t.call(this, e, n, r) } }))) })) }(); break; case "xhr": !function () { if (!("XMLHttpRequest" in l)) return; const t = XMLHttpRequest.prototype; u(t, "open", (function (t) { return function (...e) { const n = e[1], s = this.__sentry_xhr__ = { method: r(e[0]) ? e[0].toUpperCase() : e[0], url: e[1], request_headers: {} }; r(n) && "POST" === s.method && n.match(/sentry_key/) && (this.__sentry_own_request__ = !0); const o = () => { const t = this.__sentry_xhr__; if (t && 4 === this.readyState) { try { t.status_code = this.status } catch (t) { } b("xhr", { args: e, endTimestamp: Date.now(), startTimestamp: Date.now(), xhr: this }) } }; return "onreadystatechange" in this && "function" == typeof this.onreadystatechange ? u(this, "onreadystatechange", (function (t) { return function (...e) { return o(), t.apply(this, e) } })) : this.addEventListener("readystatechange", o), u(this, "setRequestHeader", (function (t) { return function (...e) { const [n, r] = e, s = this.__sentry_xhr__; return s && (s.request_headers[n] = r), t.apply(this, e) } })), t.apply(this, e) } })), u(t, "send", (function (t) { return function (...e) { return this.__sentry_xhr__ && void 0 !== e[0] && (this.__sentry_xhr__.body = e[0]), b("xhr", { args: e, startTimestamp: Date.now(), xhr: this }), t.apply(this, e) } })) }(); break; case "fetch": !function () { if (!f()) return; u(l, "fetch", (function (t) { return function (...e) { const { method: n, url: r } = function (t) { if (0 === t.length) return { method: "GET", url: "" }; if (2 === t.length) { const [e, n] = t; return { url: _(e), method: k(n, "method") ? String(n.method).toUpperCase() : "GET" } } const e = t[0]; return { url: _(e), method: k(e, "method") ? String(e.method).toUpperCase() : "GET" } }(e), s = { args: e, fetchData: { method: n, url: r }, startTimestamp: Date.now() }; return b("fetch", { ...s }), t.apply(l, e).then((t => (b("fetch", { ...s, endTimestamp: Date.now(), response: t }), t)), (t => { throw b("fetch", { ...s, endTimestamp: Date.now(), error: t }), t })) } })) }(); break; case "history": !function () { if (!function () { const t = d.chrome, e = t && t.app && t.app.runtime, n = "history" in d && !!d.history.pushState && !!d.history.replaceState; return !e && n }()) return; const t = l.onpopstate; function e(t) { return function (...e) { const n = e.length > 2 ? e[2] : void 0; if (n) { const t = v, e = String(n); v = e, b("history", { from: t, to: e }) } return t.apply(this, e) } } l.onpopstate = function (...e) { const n = l.location.href, r = v; if (v = n, b("history", { from: r, to: n }), t) try { return t.apply(this, e) } catch (t) { } }, u(l.history, "pushState", e), u(l.history, "replaceState", e) }(); break; case "error": R = l.onerror, l.onerror = function (t, e, n, r, s) { return b("error", { column: r, error: s, line: n, msg: t, url: e }), !(!R || R.__SENTRY_LOADER__) && R.apply(this, arguments) }, l.onerror.__SENTRY_INSTRUMENTED__ = !0; break; case "unhandledrejection": q = l.onunhandledrejection, l.onunhandledrejection = function (t) { return b("unhandledrejection", t), !(q && !q.__SENTRY_LOADER__) || q.apply(this, arguments) }, l.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0; break; default: return } } function g(t, e) { p[t] = p[t] || [], p[t].push(e), m(t) } function b(t, e) { if (t && p[t]) for (const n of p[t] || []) try { n(e) } catch (t) { } } function k(t, e) { return !!t && "object" == typeof t && !!t[e] } function _(t) { return "string" == typeof t ? t : t ? k(t, "url") ? t.url : t.toString ? t.toString() : "" : "" } let v; let H, T; function w(t, e = !1) { return n => { if (!n || T === n) return; if (function (t) { if ("keypress" !== t.type) return !1; try { const e = t.target; if (!e || !e.tagName) return !0; if ("INPUT" === e.tagName || "TEXTAREA" === e.tagName || e.isContentEditable) return !1 } catch (t) { } return !0 }(n)) return; const r = "keypress" === n.type ? "input" : n.type; (void 0 === H || function (t, e) { if (!t) return !0; if (t.type !== e.type) return !0; try { if (t.target !== e.target) return !0 } catch (t) { } return !1 }(T, n)) && (t({ event: n, name: r, global: e }), T = n), clearTimeout(H), H = l.setTimeout((() => { H = void 0 }), 1e3) } } let R = null; let q = null; class j { static __initStatic() { this.id = "HttpClient" } __init() { this.name = j.id } constructor(t) { j.prototype.__init.call(this), this.t = { failedRequestStatusCodes: [[500, 599]], failedRequestTargets: [/.*/], ...t } } setupOnce(t, e) { this.o = e, this.i(), this.u() } h(t, e, n) { if (this.o && this.l(e.status, e.url)) { const r = new Request(t, n), s = this.o(); let o, i, c, u; s.shouldSendDefaultPii() && ([{ headers: o, cookies: c }, { headers: i, cookies: u }] = [{ cookieHeader: "Cookie", obj: r }, { cookieHeader: "Set-Cookie", obj: e }].map((({ cookieHeader: t, obj: e }) => { const n = this.p(e.headers); let r; try { const e = n[t] || n[t.toLowerCase()] || void 0; e && (r = this.m(e)) } catch (t) { } return { headers: n, cookies: r } }))); const a = this.g({ url: r.url, method: r.method, status: e.status, requestHeaders: o, responseHeaders: i, requestCookies: c, responseCookies: u }); s.captureEvent(a) } } k(t, e, n) { if (this.o && this.l(t.status, t.responseURL)) { let r, s, o; const i = this.o(); if (i.shouldSendDefaultPii()) { try { const e = t.getResponseHeader("Set-Cookie") || t.getResponseHeader("set-cookie") || void 0; e && (s = this.m(e)) } catch (t) { } try { o = this._(t) } catch (t) { } r = n } const c = this.g({ url: t.responseURL, method: e, status: t.status, requestHeaders: r, responseHeaders: o, responseCookies: s }); i.captureEvent(c) } } v(t) { if (t) { const e = t["Content-Length"] || t["content-length"]; if (e) return parseInt(e, 10) } } m(t) { return t.split("; ").reduce(((t, e) => { const [n, r] = e.split("="); return t[n] = r, t }), {}) } p(t) { const e = {}; return t.forEach(((t, n) => { e[n] = t })), e } _(t) { const e = t.getAllResponseHeaders(); return e ? e.split("\r\n").reduce(((t, e) => { const [n, r] = e.split(": "); return t[n] = r, t }), {}) : {} } H(t) { return !!this.t.failedRequestTargets && this.t.failedRequestTargets.some((e => "string" == typeof e ? t.includes(e) : e.test(t))) } T(t) { return !!this.t.failedRequestStatusCodes && this.t.failedRequestStatusCodes.some((e => "number" == typeof e ? e === t : t >= e[0] && t <= e[1])) } i() { f() && g("fetch", (t => { const { response: e, args: n } = t, [r, s] = n; e && this.h(r, e, s) })) } u() { "XMLHttpRequest" in o && g("xhr", (t => { const { xhr: e } = t; if (!e.__sentry_xhr__) return; const { method: n, request_headers: r } = e.__sentry_xhr__; if (n) try { this.k(e, n, r) } catch (t) { } })) } R(t) { const e = this.o && this.o().getClient(); if (!e) return !1; const n = e.getDsn(); return !!n && t.includes(n.host) } l(t, e) { return this.T(t) && this.H(e) && !this.R(e) } g(t) { const e = `HTTP Client Error with status code: ${t.status}`, n = { message: e, exception: { values: [{ type: "Error", value: e }] }, request: { url: t.url, method: t.method, headers: t.requestHeaders, cookies: t.requestCookies }, contexts: { response: { status_code: t.status, headers: t.responseHeaders, cookies: t.responseCookies, body_size: this.v(t.responseHeaders) } } }; return function (t, e) { const n = function (t) { return t.exception && t.exception.values ? t.exception.values[0] : void 0 }(t); if (!n) return; const r = n.mechanism; if (n.mechanism = { type: "generic", handled: !0, ...r, ...e }, e && "data" in e) { const t = { ...r && r.data, ...e.data }; n.mechanism.data = t } }(n, { type: "http.client" }), n } } for (var S in j.__initStatic(), e.HttpClient = j, t.Sentry = t.Sentry || {}, t.Sentry.Integrations = t.Sentry.Integrations || {}, e) Object.prototype.hasOwnProperty.call(e, S) && (t.Sentry.Integrations[S] = e[S]) }(window);
