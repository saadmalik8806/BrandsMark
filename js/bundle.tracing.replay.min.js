
var Sentry = function (t) { const e = Object.prototype.toString; function n(t) { switch (e.call(t)) { case "[object Error]": case "[object Exception]": case "[object DOMException]": return !0; default: return d(t, Error) } } function i(t, n) { return e.call(t) === `[object ${n}]` } function r(t) { return i(t, "ErrorEvent") } function s(t) { return i(t, "DOMError") } function a(t) { return i(t, "String") } function o(t) { return null === t || "object" != typeof t && "function" != typeof t } function c(t) { return i(t, "Object") } function u(t) { return "undefined" != typeof Event && d(t, Event) } function h(t) { return Boolean(t && t.then && "function" == typeof t.then) } function l(t) { return "number" == typeof t && t != t } function d(t, e) { try { return t instanceof e } catch (t) { return !1 } } function f(t) { return t && t.Math == Math ? t : void 0 } const p = "object" == typeof globalThis && f(globalThis) || "object" == typeof window && f(window) || "object" == typeof self && f(self) || "object" == typeof global && f(global) || function () { return this }() || {}; function m() { return p } function _(t, e, n) { const i = n || p, r = i.__SENTRY__ = i.__SENTRY__ || {}; return r[t] || (r[t] = e()) } const y = m(); function g(t, e = {}) { try { let n = t; const i = 5, r = []; let s = 0, a = 0; const o = " > ", c = o.length; let u; const h = Array.isArray(e) ? e : e.keyAttrs, l = !Array.isArray(e) && e.maxStringLength || 80; for (; n && s++ < i && (u = b(n, h), !("html" === u || s > 1 && a + r.length * c + u.length >= l));)r.push(u), a += u.length, n = n.parentNode; return r.reverse().join(o) } catch (t) { return "<unknown>" } } function b(t, e) { const n = t, i = []; let r, s, o, c, u; if (!n || !n.tagName) return ""; i.push(n.tagName.toLowerCase()); const h = e && e.length ? e.filter((t => n.getAttribute(t))).map((t => [t, n.getAttribute(t)])) : null; if (h && h.length) h.forEach((t => { i.push(`[${t[0]}="${t[1]}"]`) })); else if (n.id && i.push(`#${n.id}`), r = n.className, r && a(r)) for (s = r.split(/\s+/), u = 0; u < s.length; u++)i.push(`.${s[u]}`); const l = ["aria-label", "type", "name", "title", "alt"]; for (u = 0; u < l.length; u++)o = l[u], c = n.getAttribute(o), c && i.push(`[${o}="${c}"]`); return i.join("") } class w extends Error { constructor(t, e = "warn") { super(t), this.message = t, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = e } } const v = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/; function k(t, e = !1) { const { host: n, path: i, pass: r, port: s, projectId: a, protocol: o, publicKey: c } = t; return `${o}://${c}${e && r ? `:${r}` : ""}@${n}${s ? `:${s}` : ""}/${i ? `${i}/` : i}${a}` } function S(t) { return { protocol: t.protocol, publicKey: t.publicKey || "", pass: t.pass || "", host: t.host, port: t.port || "", path: t.path || "", projectId: t.projectId } } function x(t) { return "string" == typeof t ? function (t) { const e = v.exec(t); if (!e) throw new w(`Invalid Sentry Dsn: ${t}`); const [n, i, r = "", s, a = "", o] = e.slice(1); let c = "", u = o; const h = u.split("/"); if (h.length > 1 && (c = h.slice(0, -1).join("/"), u = h.pop()), u) { const t = u.match(/^\d+/); t && (u = t[0]) } return S({ host: s, pass: r, path: c, projectId: u, port: a, protocol: n, publicKey: i }) }(t) : S(t) } const T = ["debug", "info", "warn", "error", "log", "assert", "trace"]; function E(t, e = 0) { return "string" != typeof t || 0 === e || t.length <= e ? t : `${t.slice(0, e)}...` } function I(t, e) { if (!Array.isArray(t)) return ""; const n = []; for (let e = 0; e < t.length; e++) { const i = t[e]; try { n.push(String(i)) } catch (t) { n.push("[value cannot be serialized]") } } return n.join(e) } function A(t, e, n = !1) { return !!a(t) && (i(e, "RegExp") ? e.test(t) : !!a(e) && (n ? t === e : t.includes(e))) } function C(t, e = [], n = !1) { return e.some((e => A(t, e, n))) } function O(t, e, n) { if (!(e in t)) return; const i = t[e], r = n(i); if ("function" == typeof r) try { z(r, i) } catch (t) { } t[e] = r } function R(t, e, n) { Object.defineProperty(t, e, { value: n, writable: !0, configurable: !0 }) } function z(t, e) { const n = e.prototype || {}; t.prototype = e.prototype = n, R(t, "__sentry_original__", e) } function D(t) { return t.__sentry_original__ } function L(t) { if (n(t)) return { message: t.message, name: t.name, stack: t.stack, ...$(t) }; if (u(t)) { const e = { type: t.type, target: M(t.target), currentTarget: M(t.currentTarget), ...$(t) }; return "undefined" != typeof CustomEvent && d(t, CustomEvent) && (e.detail = t.detail), e } return t } function M(t) { try { return e = t, "undefined" != typeof Element && d(e, Element) ? g(t) : Object.prototype.toString.call(t) } catch (t) { return "<unknown>" } var e } function $(t) { if ("object" == typeof t && null !== t) { const e = {}; for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); return e } return {} } function N(t, e = 40) { const n = Object.keys(L(t)); if (n.sort(), !n.length) return "[object has no keys]"; if (n[0].length >= e) return E(n[0], e); for (let t = n.length; t > 0; t--) { const i = n.slice(0, t).join(", "); if (!(i.length > e)) return t === n.length ? i : E(i, e) } return "" } function F(t) { return j(t, new Map) } function j(t, e) { if (c(t)) { const n = e.get(t); if (void 0 !== n) return n; const i = {}; e.set(t, i); for (const n of Object.keys(t)) void 0 !== t[n] && (i[n] = j(t[n], e)); return i } if (Array.isArray(t)) { const n = e.get(t); if (void 0 !== n) return n; const i = []; return e.set(t, i), t.forEach((t => { i.push(j(t, e)) })), i } return t } !function () { const t = { enable: () => { }, disable: () => { } }; T.forEach((e => { t[e] = () => { } })) }(); const U = /\(error: (.*)\)/; function B(...t) { const e = t.sort(((t, e) => t[0] - e[0])).map((t => t[1])); return (t, n = 0) => { const i = [], r = t.split("\n"); for (let t = n; t < r.length; t++) { const n = r[t]; if (n.length > 1024) continue; const s = U.test(n) ? n.replace(U, "$1") : n; if (!s.match(/\S*Error: /)) { for (const t of e) { const e = t(s); if (e) { i.push(e); break } } if (i.length >= 50) break } } return function (t) { if (!t.length) return []; const e = t.slice(0, 50), n = e[e.length - 1].function; n && /sentryWrapped/.test(n) && e.pop(); e.reverse(); const i = e[e.length - 1].function; i && /captureMessage|captureException/.test(i) && e.pop(); return e.map((t => ({ ...t, filename: t.filename || e[e.length - 1].filename, function: t.function || "?" }))) }(i) } } const H = "<anonymous>"; function Z(t) { try { return t && "function" == typeof t && t.name || H } catch (t) { return H } } const P = m(); function q() { if (!("fetch" in P)) return !1; try { return new Headers, new Request("http://www.example.com"), new Response, !0 } catch (t) { return !1 } } function W(t) { return t && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString()) } const X = m(); const G = m(), J = {}, K = {}; function Y(t) { if (!K[t]) switch (K[t] = !0, t) { case "console": !function () { if (!("console" in G)) return; T.forEach((function (t) { t in G.console && O(G.console, t, (function (e) { return function (...n) { Q("console", { args: n, level: t }), e && e.apply(G.console, n) } })) })) }(); break; case "dom": !function () { if (!("document" in G)) return; const t = Q.bind(null, "dom"), e = st(t, !0); G.document.addEventListener("click", e, !1), G.document.addEventListener("keypress", e, !1), ["EventTarget", "Node"].forEach((e => { const n = G[e] && G[e].prototype; n && n.hasOwnProperty && n.hasOwnProperty("addEventListener") && (O(n, "addEventListener", (function (e) { return function (n, i, r) { if ("click" === n || "keypress" == n) try { const i = this, s = i.__sentry_instrumentation_handlers__ = i.__sentry_instrumentation_handlers__ || {}, a = s[n] = s[n] || { refCount: 0 }; if (!a.handler) { const i = st(t); a.handler = i, e.call(this, n, i, r) } a.refCount++ } catch (t) { } return e.call(this, n, i, r) } })), O(n, "removeEventListener", (function (t) { return function (e, n, i) { if ("click" === e || "keypress" == e) try { const n = this, r = n.__sentry_instrumentation_handlers__ || {}, s = r[e]; s && (s.refCount--, s.refCount <= 0 && (t.call(this, e, s.handler, i), s.handler = void 0, delete r[e]), 0 === Object.keys(r).length && delete n.__sentry_instrumentation_handlers__) } catch (t) { } return t.call(this, e, n, i) } }))) })) }(); break; case "xhr": !function () { if (!("XMLHttpRequest" in G)) return; const t = XMLHttpRequest.prototype; O(t, "open", (function (t) { return function (...e) { const n = e[1], i = this.__sentry_xhr_v2__ = { method: a(e[0]) ? e[0].toUpperCase() : e[0], url: e[1], request_headers: {} }; a(n) && "POST" === i.method && n.match(/sentry_key/) && (this.__sentry_own_request__ = !0); const r = () => { const t = this.__sentry_xhr_v2__; if (t && 4 === this.readyState) { try { t.status_code = this.status } catch (t) { } Q("xhr", { args: e, endTimestamp: Date.now(), startTimestamp: Date.now(), xhr: this }) } }; return "onreadystatechange" in this && "function" == typeof this.onreadystatechange ? O(this, "onreadystatechange", (function (t) { return function (...e) { return r(), t.apply(this, e) } })) : this.addEventListener("readystatechange", r), O(this, "setRequestHeader", (function (t) { return function (...e) { const [n, i] = e, r = this.__sentry_xhr_v2__; return r && (r.request_headers[n.toLowerCase()] = i), t.apply(this, e) } })), t.apply(this, e) } })), O(t, "send", (function (t) { return function (...e) { const n = this.__sentry_xhr_v2__; return n && void 0 !== e[0] && (n.body = e[0]), Q("xhr", { args: e, startTimestamp: Date.now(), xhr: this }), t.apply(this, e) } })) }(); break; case "fetch": !function () { if (!function () { if (!q()) return !1; if (W(P.fetch)) return !0; let t = !1; const e = P.document; if (e && "function" == typeof e.createElement) try { const n = e.createElement("iframe"); n.hidden = !0, e.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (t = W(n.contentWindow.fetch)), e.head.removeChild(n) } catch (t) { } return t }()) return; O(G, "fetch", (function (t) { return function (...e) { const { method: n, url: i } = function (t) { if (0 === t.length) return { method: "GET", url: "" }; if (2 === t.length) { const [e, n] = t; return { url: et(e), method: tt(n, "method") ? String(n.method).toUpperCase() : "GET" } } const e = t[0]; return { url: et(e), method: tt(e, "method") ? String(e.method).toUpperCase() : "GET" } }(e), r = { args: e, fetchData: { method: n, url: i }, startTimestamp: Date.now() }; return Q("fetch", { ...r }), t.apply(G, e).then((t => (Q("fetch", { ...r, endTimestamp: Date.now(), response: t }), t)), (t => { throw Q("fetch", { ...r, endTimestamp: Date.now(), error: t }), t })) } })) }(); break; case "history": !function () { if (!function () { const t = X.chrome, e = t && t.app && t.app.runtime, n = "history" in X && !!X.history.pushState && !!X.history.replaceState; return !e && n }()) return; const t = G.onpopstate; function e(t) { return function (...e) { const n = e.length > 2 ? e[2] : void 0; if (n) { const t = nt, e = String(n); nt = e, Q("history", { from: t, to: e }) } return t.apply(this, e) } } G.onpopstate = function (...e) { const n = G.location.href, i = nt; if (nt = n, Q("history", { from: i, to: n }), t) try { return t.apply(this, e) } catch (t) { } }, O(G.history, "pushState", e), O(G.history, "replaceState", e) }(); break; case "error": at = G.onerror, G.onerror = function (t, e, n, i, r) { return Q("error", { column: i, error: r, line: n, msg: t, url: e }), !(!at || at.__SENTRY_LOADER__) && at.apply(this, arguments) }, G.onerror.__SENTRY_INSTRUMENTED__ = !0; break; case "unhandledrejection": ot = G.onunhandledrejection, G.onunhandledrejection = function (t) { return Q("unhandledrejection", t), !(ot && !ot.__SENTRY_LOADER__) || ot.apply(this, arguments) }, G.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0; break; default: return } } function V(t, e) { J[t] = J[t] || [], J[t].push(e), Y(t) } function Q(t, e) { if (t && J[t]) for (const n of J[t] || []) try { n(e) } catch (t) { } } function tt(t, e) { return !!t && "object" == typeof t && !!t[e] } function et(t) { return "string" == typeof t ? t : t ? tt(t, "url") ? t.url : t.toString ? t.toString() : "" : "" } let nt; let it, rt; function st(t, e = !1) { return n => { if (!n || rt === n) return; if (function (t) { if ("keypress" !== t.type) return !1; try { const e = t.target; if (!e || !e.tagName) return !0; if ("INPUT" === e.tagName || "TEXTAREA" === e.tagName || e.isContentEditable) return !1 } catch (t) { } return !0 }(n)) return; const i = "keypress" === n.type ? "input" : n.type; (void 0 === it || function (t, e) { if (!t) return !0; if (t.type !== e.type) return !0; try { if (t.target !== e.target) return !0 } catch (t) { } return !1 }(rt, n)) && (t({ event: n, name: i, global: e }), rt = n), clearTimeout(it), it = G.setTimeout((() => { it = void 0 }), 1e3) } } let at = null; let ot = null; function ct() { const t = p, e = t.crypto || t.msCrypto; if (e && e.randomUUID) return e.randomUUID().replace(/-/g, ""); const n = e && e.getRandomValues ? () => e.getRandomValues(new Uint8Array(1))[0] : () => 16 * Math.random(); return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (t => (t ^ (15 & n()) >> t / 4).toString(16))) } function ut(t) { return t.exception && t.exception.values ? t.exception.values[0] : void 0 } function ht(t) { const { message: e, event_id: n } = t; if (e) return e; const i = ut(t); return i ? i.type && i.value ? `${i.type}: ${i.value}` : i.type || i.value || n || "<unknown>" : n || "<unknown>" } function lt(t, e, n) { const i = t.exception = t.exception || {}, r = i.values = i.values || [], s = r[0] = r[0] || {}; s.value || (s.value = e || ""), s.type || (s.type = n || "Error") } function dt(t, e) { const n = ut(t); if (!n) return; const i = n.mechanism; if (n.mechanism = { type: "generic", handled: !0, ...i, ...e }, e && "data" in e) { const t = { ...i && i.data, ...e.data }; n.mechanism.data = t } } function ft(t) { if (t && t.__sentry_captured__) return !0; try { R(t, "__sentry_captured__", !0) } catch (t) { } return !1 } function pt(t) { return Array.isArray(t) ? t : [t] } function mt(t, e = 1 / 0, n = 1 / 0) { try { return yt("", t, e, n) } catch (t) { return { ERROR: `**non-serializable** (${t})` } } } function _t(t, e = 3, n = 102400) { const i = mt(t, e); return r = i, function (t) { return ~-encodeURI(t).split(/%..|./).length }(JSON.stringify(r)) > n ? _t(t, e - 1, n) : i; var r } function yt(t, e, n = 1 / 0, i = 1 / 0, r = function () { const t = "function" == typeof WeakSet, e = t ? new WeakSet : []; return [function (n) { if (t) return !!e.has(n) || (e.add(n), !1); for (let t = 0; t < e.length; t++)if (e[t] === n) return !0; return e.push(n), !1 }, function (n) { if (t) e.delete(n); else for (let t = 0; t < e.length; t++)if (e[t] === n) { e.splice(t, 1); break } }] }()) { const [s, a] = r; if (null === e || ["number", "boolean", "string"].includes(typeof e) && !l(e)) return e; const o = function (t, e) { try { if ("domain" === t && e && "object" == typeof e && e.t) return "[Domain]"; if ("domainEmitter" === t) return "[DomainEmitter]"; if ("undefined" != typeof global && e === global) return "[Global]"; if ("undefined" != typeof window && e === window) return "[Window]"; if ("undefined" != typeof document && e === document) return "[Document]"; if (c(n = e) && "nativeEvent" in n && "preventDefault" in n && "stopPropagation" in n) return "[SyntheticEvent]"; if ("number" == typeof e && e != e) return "[NaN]"; if (void 0 === e) return "[undefined]"; if ("function" == typeof e) return `[Function: ${Z(e)}]`; if ("symbol" == typeof e) return `[${String(e)}]`; if ("bigint" == typeof e) return `[BigInt: ${String(e)}]`; const i = function (t) { const e = Object.getPrototypeOf(t); return e ? e.constructor.name : "null prototype" }(e); return /^HTML(\w*)Element$/.test(i) ? `[HTMLElement: ${i}]` : `[object ${i}]` } catch (t) { return `**non-serializable** (${t})` } var n }(t, e); if (!o.startsWith("[object ")) return o; if (e.__sentry_skip_normalization__) return e; let u = n; if ("number" == typeof e.__sentry_override_normalization_depth__ && (u = e.__sentry_override_normalization_depth__), 0 === u) return o.replace("object ", ""); if (s(e)) return "[Circular ~]"; const h = e; if (h && "function" == typeof h.toJSON) try { return yt("", h.toJSON(), u - 1, i, r) } catch (t) { } const d = Array.isArray(e) ? [] : {}; let f = 0; const p = L(e); for (const t in p) { if (!Object.prototype.hasOwnProperty.call(p, t)) continue; if (f >= i) { d[t] = "[MaxProperties ~]"; break } const e = p[t]; d[t] = yt(t, e, u - 1, i, r), f++ } return a(e), d } var gt; function bt(t) { return new vt((e => { e(t) })) } function wt(t) { return new vt(((e, n) => { n(t) })) } !function (t) { t[t.PENDING = 0] = "PENDING"; t[t.RESOLVED = 1] = "RESOLVED"; t[t.REJECTED = 2] = "REJECTED" }(gt || (gt = {})); class vt { __init() { this.i = gt.PENDING } __init2() { this.o = [] } constructor(t) { vt.prototype.__init.call(this), vt.prototype.__init2.call(this), vt.prototype.__init3.call(this), vt.prototype.__init4.call(this), vt.prototype.__init5.call(this), vt.prototype.__init6.call(this); try { t(this.u, this.h) } catch (t) { this.h(t) } } then(t, e) { return new vt(((n, i) => { this.o.push([!1, e => { if (t) try { n(t(e)) } catch (t) { i(t) } else n(e) }, t => { if (e) try { n(e(t)) } catch (t) { i(t) } else i(t) }]), this.l() })) } catch(t) { return this.then((t => t), t) } finally(t) { return new vt(((e, n) => { let i, r; return this.then((e => { r = !1, i = e, t && t() }), (e => { r = !0, i = e, t && t() })).then((() => { r ? n(i) : e(i) })) })) } __init3() { this.u = t => { this.p(gt.RESOLVED, t) } } __init4() { this.h = t => { this.p(gt.REJECTED, t) } } __init5() { this.p = (t, e) => { this.i === gt.PENDING && (h(e) ? e.then(this.u, this.h) : (this.i = t, this.m = e, this.l())) } } __init6() { this.l = () => { if (this.i === gt.PENDING) return; const t = this.o.slice(); this.o = [], t.forEach((t => { t[0] || (this.i === gt.RESOLVED && t[1](this.m), this.i === gt.REJECTED && t[2](this.m), t[0] = !0) })) } } } function kt(t) { const e = []; function n(t) { return e.splice(e.indexOf(t), 1)[0] } return { $: e, add: function (i) { if (!(void 0 === t || e.length < t)) return wt(new w("Not adding Promise because buffer limit was reached.")); const r = i(); return -1 === e.indexOf(r) && e.push(r), r.then((() => n(r))).then(null, (() => n(r).then(null, (() => { })))), r }, drain: function (t) { return new vt(((n, i) => { let r = e.length; if (!r) return n(!0); const s = setTimeout((() => { t && t > 0 && n(!1) }), t); e.forEach((t => { bt(t).then((() => { --r || (clearTimeout(s), n(!0)) }), i) })) })) } } } function St(t) { if (!t) return {}; const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/); if (!e) return {}; const n = e[6] || "", i = e[8] || ""; return { host: e[4], path: e[5], protocol: e[2], search: n, hash: i, relative: e[5] + n + i } } const xt = ["fatal", "error", "warning", "log", "info", "debug"]; const Tt = m(), Et = { nowSeconds: () => Date.now() / 1e3 }; const It = function () { const { performance: t } = Tt; if (!t || !t.now) return; return { now: () => t.now(), timeOrigin: Date.now() - t.now() } }(), At = void 0 === It ? Et : { nowSeconds: () => (It.timeOrigin + It.now()) / 1e3 }, Ct = Et.nowSeconds.bind(Et), Ot = At.nowSeconds.bind(At), Rt = (() => { const { performance: t } = Tt; if (!t || !t.now) return; const e = 36e5, n = t.now(), i = Date.now(), r = t.timeOrigin ? Math.abs(t.timeOrigin + n - i) : e, s = r < e, a = t.timing && t.timing.navigationStart, o = "number" == typeof a ? Math.abs(a + n - i) : e; return s || o < e ? r <= o ? t.timeOrigin : a : i })(), zt = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"); function Dt(t, e = []) { return [t, e] } function Lt(t, e) { const [n, i] = t; return [n, [...i, e]] } function Mt(t, e) { const n = t[1]; for (const t of n) { if (e(t, t[0].type)) return !0 } return !1 } function $t(t, e) { return (e || new TextEncoder).encode(t) } function Nt(t, e) { const [n, i] = t; let r = JSON.stringify(n); function s(t) { "string" == typeof r ? r = "string" == typeof t ? r + t : [$t(r, e), t] : r.push("string" == typeof t ? $t(t, e) : t) } for (const t of i) { const [e, n] = t; if (s(`\n${JSON.stringify(e)}\n`), "string" == typeof n || n instanceof Uint8Array) s(n); else { let t; try { t = JSON.stringify(n) } catch (e) { t = JSON.stringify(mt(n)) } s(t) } } return "string" == typeof r ? r : function (t) { const e = t.reduce(((t, e) => t + e.length), 0), n = new Uint8Array(e); let i = 0; for (const e of t) n.set(e, i), i += e.length; return n }(r) } function Ft(t, e) { const n = "string" == typeof t.data ? $t(t.data, e) : t.data; return [F({ type: "attachment", length: n.length, filename: t.filename, content_type: t.contentType, attachment_type: t.attachmentType }), n] } const jt = { session: "session", sessions: "session", attachment: "attachment", transaction: "transaction", event: "error", client_report: "internal", user_report: "default", profile: "profile", replay_event: "replay", replay_recording: "replay", check_in: "monitor" }; function Ut(t) { return jt[t] } function Bt(t) { if (!t || !t.sdk) return; const { name: e, version: n } = t.sdk; return { name: e, version: n } } function Ht(t, e, n, i) { const r = t.sdkProcessingMetadata && t.sdkProcessingMetadata.dynamicSamplingContext; return { event_id: t.event_id, sent_at: (new Date).toISOString(), ...e && { sdk: e }, ...!!n && { dsn: k(i) }, ...r && { trace: F({ ...r }) } } } function Zt(t, { statusCode: e, headers: n }, i = Date.now()) { const r = { ...t }, s = n && n["x-sentry-rate-limits"], a = n && n["retry-after"]; if (s) for (const t of s.trim().split(",")) { const [e, n] = t.split(":", 2), s = parseInt(e, 10), a = 1e3 * (isNaN(s) ? 60 : s); if (n) for (const t of n.split(";")) r[t] = i + a; else r.all = i + a } else a ? r.all = i + function (t, e = Date.now()) { const n = parseInt(`${t}`, 10); if (!isNaN(n)) return 1e3 * n; const i = Date.parse(`${t}`); return isNaN(i) ? 6e4 : i - e }(a, i) : 429 === e && (r.all = i + 6e4); return r } const Pt = "baggage", qt = "sentry-", Wt = /^sentry-/; function Xt(t) { return function (t) { if (0 === Object.keys(t).length) return; return Object.entries(t).reduce(((t, [e, n], i) => { const r = `${encodeURIComponent(e)}=${encodeURIComponent(n)}`, s = 0 === i ? r : `${t},${r}`; return s.length > 8192 ? t : s }), "") }(Object.entries(t).reduce(((t, [e, n]) => (n && (t[`sentry-${e}`] = n), t)), {})) } function Gt(t) { return t.split(",").map((t => t.split("=").map((t => decodeURIComponent(t.trim()))))).reduce(((t, [e, n]) => (t[e] = n, t)), {}) } const Jt = "production"; function Kt(t) { const e = Ot(), n = { sid: ct(), init: !0, timestamp: e, started: e, duration: 0, status: "ok", errors: 0, ignoreDuration: !1, toJSON: () => function (t) { return F({ sid: `${t.sid}`, init: t.init, started: new Date(1e3 * t.started).toISOString(), timestamp: new Date(1e3 * t.timestamp).toISOString(), status: t.status, errors: t.errors, did: "number" == typeof t.did || "string" == typeof t.did ? `${t.did}` : void 0, duration: t.duration, attrs: { release: t.release, environment: t.environment, ip_address: t.ipAddress, user_agent: t.userAgent } }) }(n) }; return t && Yt(n, t), n } function Yt(t, e = {}) { if (e.user && (!t.ipAddress && e.user.ip_address && (t.ipAddress = e.user.ip_address), t.did || e.did || (t.did = e.user.id || e.user.email || e.user.username)), t.timestamp = e.timestamp || Ot(), e.ignoreDuration && (t.ignoreDuration = e.ignoreDuration), e.sid && (t.sid = 32 === e.sid.length ? e.sid : ct()), void 0 !== e.init && (t.init = e.init), !t.did && e.did && (t.did = `${e.did}`), "number" == typeof e.started && (t.started = e.started), t.ignoreDuration) t.duration = void 0; else if ("number" == typeof e.duration) t.duration = e.duration; else { const e = t.timestamp - t.started; t.duration = e >= 0 ? e : 0 } e.release && (t.release = e.release), e.environment && (t.environment = e.environment), !t.ipAddress && e.ipAddress && (t.ipAddress = e.ipAddress), !t.userAgent && e.userAgent && (t.userAgent = e.userAgent), "number" == typeof e.errors && (t.errors = e.errors), e.status && (t.status = e.status) } class Vt { constructor() { this._ = !1, this.g = [], this.v = [], this.k = [], this.S = [], this.T = {}, this.I = {}, this.A = {}, this.C = {}, this.O = {} } static clone(t) { const e = new Vt; return t && (e.k = [...t.k], e.I = { ...t.I }, e.A = { ...t.A }, e.C = { ...t.C }, e.T = t.T, e.R = t.R, e.D = t.D, e.L = t.L, e.M = t.M, e.N = t.N, e.v = [...t.v], e.F = t.F, e.S = [...t.S], e.O = { ...t.O }), e } addScopeListener(t) { this.g.push(t) } addEventProcessor(t) { return this.v.push(t), this } setUser(t) { return this.T = t || {}, this.L && Yt(this.L, { user: t }), this.j(), this } getUser() { return this.T } getRequestSession() { return this.F } setRequestSession(t) { return this.F = t, this } setTags(t) { return this.I = { ...this.I, ...t }, this.j(), this } setTag(t, e) { return this.I = { ...this.I, [t]: e }, this.j(), this } setExtras(t) { return this.A = { ...this.A, ...t }, this.j(), this } setExtra(t, e) { return this.A = { ...this.A, [t]: e }, this.j(), this } setFingerprint(t) { return this.N = t, this.j(), this } setLevel(t) { return this.R = t, this.j(), this } setTransactionName(t) { return this.M = t, this.j(), this } setContext(t, e) { return null === e ? delete this.C[t] : this.C[t] = e, this.j(), this } setSpan(t) { return this.D = t, this.j(), this } getSpan() { return this.D } getTransaction() { const t = this.getSpan(); return t && t.transaction } setSession(t) { return t ? this.L = t : delete this.L, this.j(), this } getSession() { return this.L } update(t) { if (!t) return this; if ("function" == typeof t) { const e = t(this); return e instanceof Vt ? e : this } return t instanceof Vt ? (this.I = { ...this.I, ...t.I }, this.A = { ...this.A, ...t.A }, this.C = { ...this.C, ...t.C }, t.T && Object.keys(t.T).length && (this.T = t.T), t.R && (this.R = t.R), t.N && (this.N = t.N), t.F && (this.F = t.F)) : c(t) && (t = t, this.I = { ...this.I, ...t.tags }, this.A = { ...this.A, ...t.extra }, this.C = { ...this.C, ...t.contexts }, t.user && (this.T = t.user), t.level && (this.R = t.level), t.fingerprint && (this.N = t.fingerprint), t.requestSession && (this.F = t.requestSession)), this } clear() { return this.k = [], this.I = {}, this.A = {}, this.T = {}, this.C = {}, this.R = void 0, this.M = void 0, this.N = void 0, this.F = void 0, this.D = void 0, this.L = void 0, this.j(), this.S = [], this } addBreadcrumb(t, e) { const n = "number" == typeof e ? e : 100; if (n <= 0) return this; const i = { timestamp: Ct(), ...t }; return this.k = [...this.k, i].slice(-n), this.j(), this } getLastBreadcrumb() { return this.k[this.k.length - 1] } clearBreadcrumbs() { return this.k = [], this.j(), this } addAttachment(t) { return this.S.push(t), this } getAttachments() { return this.S } clearAttachments() { return this.S = [], this } applyToEvent(t, e = {}) { if (this.A && Object.keys(this.A).length && (t.extra = { ...this.A, ...t.extra }), this.I && Object.keys(this.I).length && (t.tags = { ...this.I, ...t.tags }), this.T && Object.keys(this.T).length && (t.user = { ...this.T, ...t.user }), this.C && Object.keys(this.C).length && (t.contexts = { ...this.C, ...t.contexts }), this.R && (t.level = this.R), this.M && (t.transaction = this.M), this.D) { t.contexts = { trace: this.D.getTraceContext(), ...t.contexts }; const e = this.D.transaction; if (e) { t.sdkProcessingMetadata = { dynamicSamplingContext: e.getDynamicSamplingContext(), ...t.sdkProcessingMetadata }; const n = e.name; n && (t.tags = { transaction: n, ...t.tags }) } } return this.U(t), t.breadcrumbs = [...t.breadcrumbs || [], ...this.k], t.breadcrumbs = t.breadcrumbs.length > 0 ? t.breadcrumbs : void 0, t.sdkProcessingMetadata = { ...t.sdkProcessingMetadata, ...this.O }, this.B([...Qt(), ...this.v], t, e) } setSDKProcessingMetadata(t) { return this.O = { ...this.O, ...t }, this } B(t, e, n, i = 0) { return new vt(((r, s) => { const a = t[i]; if (null === e || "function" != typeof a) r(e); else { const o = a({ ...e }, n); h(o) ? o.then((e => this.B(t, e, n, i + 1).then(r))).then(null, s) : this.B(t, o, n, i + 1).then(r).then(null, s) } })) } j() { this._ || (this._ = !0, this.g.forEach((t => { t(this) })), this._ = !1) } U(t) { t.fingerprint = t.fingerprint ? pt(t.fingerprint) : [], this.N && (t.fingerprint = t.fingerprint.concat(this.N)), t.fingerprint && !t.fingerprint.length && delete t.fingerprint } } function Qt() { return _("globalEventProcessors", (() => [])) } function te(t) { Qt().push(t) } const ee = 100; class ne { constructor(t, e = new Vt, n = 4) { this.H = n, this.Z = [{ scope: e }], t && this.bindClient(t) } isOlderThan(t) { return this.H < t } bindClient(t) { this.getStackTop().client = t, t && t.setupIntegrations && t.setupIntegrations() } pushScope() { const t = Vt.clone(this.getScope()); return this.getStack().push({ client: this.getClient(), scope: t }), t } popScope() { return !(this.getStack().length <= 1) && !!this.getStack().pop() } withScope(t) { const e = this.pushScope(); try { t(e) } finally { this.popScope() } } getClient() { return this.getStackTop().client } getScope() { return this.getStackTop().scope } getStack() { return this.Z } getStackTop() { return this.Z[this.Z.length - 1] } captureException(t, e) { const n = this.P = e && e.event_id ? e.event_id : ct(), i = new Error("Sentry syntheticException"); return this.q(((r, s) => { r.captureException(t, { originalException: t, syntheticException: i, ...e, event_id: n }, s) })), n } captureMessage(t, e, n) { const i = this.P = n && n.event_id ? n.event_id : ct(), r = new Error(t); return this.q(((s, a) => { s.captureMessage(t, e, { originalException: t, syntheticException: r, ...n, event_id: i }, a) })), i } captureEvent(t, e) { const n = e && e.event_id ? e.event_id : ct(); return t.type || (this.P = n), this.q(((i, r) => { i.captureEvent(t, { ...e, event_id: n }, r) })), n } lastEventId() { return this.P } addBreadcrumb(t, e) { const { scope: n, client: i } = this.getStackTop(); if (!i) return; const { beforeBreadcrumb: r = null, maxBreadcrumbs: s = ee } = i.getOptions && i.getOptions() || {}; if (s <= 0) return; const a = { timestamp: Ct(), ...t }, o = r ? function (t) { if (!("console" in p)) return t(); const e = p.console, n = {}; T.forEach((t => { const i = e[t] && e[t].__sentry_original__; t in e && i && (n[t] = e[t], e[t] = i) })); try { return t() } finally { Object.keys(n).forEach((t => { e[t] = n[t] })) } }((() => r(a, e))) : a; null !== o && (i.emit && i.emit("beforeAddBreadcrumb", o, e), n.addBreadcrumb(o, s)) } setUser(t) { this.getScope().setUser(t) } setTags(t) { this.getScope().setTags(t) } setExtras(t) { this.getScope().setExtras(t) } setTag(t, e) { this.getScope().setTag(t, e) } setExtra(t, e) { this.getScope().setExtra(t, e) } setContext(t, e) { this.getScope().setContext(t, e) } configureScope(t) { const { scope: e, client: n } = this.getStackTop(); n && t(e) } run(t) { const e = re(this); try { t(this) } finally { re(e) } } getIntegration(t) { const e = this.getClient(); if (!e) return null; try { return e.getIntegration(t) } catch (t) { return null } } startTransaction(t, e) { return this.W("startTransaction", t, e) } traceHeaders() { return this.W("traceHeaders") } captureSession(t = !1) { if (t) return this.endSession(); this.X() } endSession() { const t = this.getStackTop().scope, e = t.getSession(); e && function (t, e) { let n = {}; e ? n = { status: e } : "ok" === t.status && (n = { status: "exited" }), Yt(t, n) }(e), this.X(), t.setSession() } startSession(t) { const { scope: e, client: n } = this.getStackTop(), { release: i, environment: r = Jt } = n && n.getOptions() || {}, { userAgent: s } = p.navigator || {}, a = Kt({ release: i, environment: r, user: e.getUser(), ...s && { userAgent: s }, ...t }), o = e.getSession && e.getSession(); return o && "ok" === o.status && Yt(o, { status: "exited" }), this.endSession(), e.setSession(a), a } shouldSendDefaultPii() { const t = this.getClient(), e = t && t.getOptions(); return Boolean(e && e.sendDefaultPii) } X() { const { scope: t, client: e } = this.getStackTop(), n = t.getSession(); n && e && e.captureSession && e.captureSession(n) } q(t) { const { scope: e, client: n } = this.getStackTop(); n && t(n, e) } W(t, ...e) { const n = ie().__SENTRY__; if (n && n.extensions && "function" == typeof n.extensions[t]) return n.extensions[t].apply(this, e) } } function ie() { return p.__SENTRY__ = p.__SENTRY__ || { extensions: {}, hub: void 0 }, p } function re(t) { const e = ie(), n = ae(e); return oe(e, t), n } function se() { const t = ie(); if (t.__SENTRY__ && t.__SENTRY__.acs) { const e = t.__SENTRY__.acs.getCurrentHub(); if (e) return e } return function (t = ie()) { e = t, e && e.__SENTRY__ && e.__SENTRY__.hub && !ae(t).isOlderThan(4) || oe(t, new ne); var e; return ae(t) }(t) } function ae(t) { return _("hub", (() => new ne), t) } function oe(t, e) { if (!t) return !1; return (t.__SENTRY__ = t.__SENTRY__ || {}).hub = e, !0 } function ce(t) { if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__) return !1; const e = se().getClient(), n = t || e && e.getOptions(); return !!n && (n.enableTracing || "tracesSampleRate" in n || "tracesSampler" in n) } function ue(t) { return (t || se()).getScope().getTransaction() } let he = !1; function le() { const t = ue(); if (t) { const e = "internal_error"; t.setStatus(e) } } le.tag = "sentry_tracingErrorCallback"; class de { __init() { this.spans = [] } constructor(t = 1e3) { de.prototype.__init.call(this), this.G = t } add(t) { this.spans.length > this.G ? t.spanRecorder = void 0 : this.spans.push(t) } } class fe { __init2() { this.traceId = ct() } __init3() { this.spanId = ct().substring(16) } __init4() { this.startTimestamp = Ot() } __init5() { this.tags = {} } __init6() { this.data = {} } __init7() { this.instrumenter = "sentry" } constructor(t) { if (fe.prototype.__init2.call(this), fe.prototype.__init3.call(this), fe.prototype.__init4.call(this), fe.prototype.__init5.call(this), fe.prototype.__init6.call(this), fe.prototype.__init7.call(this), !t) return this; t.traceId && (this.traceId = t.traceId), t.spanId && (this.spanId = t.spanId), t.parentSpanId && (this.parentSpanId = t.parentSpanId), "sampled" in t && (this.sampled = t.sampled), t.op && (this.op = t.op), t.description && (this.description = t.description), t.data && (this.data = t.data), t.tags && (this.tags = t.tags), t.status && (this.status = t.status), t.startTimestamp && (this.startTimestamp = t.startTimestamp), t.endTimestamp && (this.endTimestamp = t.endTimestamp), t.instrumenter && (this.instrumenter = t.instrumenter) } startChild(t) { const e = new fe({ ...t, parentSpanId: this.spanId, sampled: this.sampled, traceId: this.traceId }); return e.spanRecorder = this.spanRecorder, e.spanRecorder && e.spanRecorder.add(e), e.transaction = this.transaction, e } setTag(t, e) { return this.tags = { ...this.tags, [t]: e }, this } setData(t, e) { return this.data = { ...this.data, [t]: e }, this } setStatus(t) { return this.status = t, this } setHttpStatus(t) { this.setTag("http.status_code", String(t)); const e = function (t) { if (t < 400 && t >= 100) return "ok"; if (t >= 400 && t < 500) switch (t) { case 401: return "unauthenticated"; case 403: return "permission_denied"; case 404: return "not_found"; case 409: return "already_exists"; case 413: return "failed_precondition"; case 429: return "resource_exhausted"; default: return "invalid_argument" }if (t >= 500 && t < 600) switch (t) { case 501: return "unimplemented"; case 503: return "unavailable"; case 504: return "deadline_exceeded"; default: return "internal_error" }return "unknown_error" }(t); return "unknown_error" !== e && this.setStatus(e), this } isSuccess() { return "ok" === this.status } finish(t) { this.endTimestamp = "number" == typeof t ? t : Ot() } toTraceparent() { let t = ""; return void 0 !== this.sampled && (t = this.sampled ? "-1" : "-0"), `${this.traceId}-${this.spanId}${t}` } toContext() { return F({ data: this.data, description: this.description, endTimestamp: this.endTimestamp, op: this.op, parentSpanId: this.parentSpanId, sampled: this.sampled, spanId: this.spanId, startTimestamp: this.startTimestamp, status: this.status, tags: this.tags, traceId: this.traceId }) } updateWithContext(t) { return this.data = t.data || {}, this.description = t.description, this.endTimestamp = t.endTimestamp, this.op = t.op, this.parentSpanId = t.parentSpanId, this.sampled = t.sampled, this.spanId = t.spanId || this.spanId, this.startTimestamp = t.startTimestamp || this.startTimestamp, this.status = t.status, this.tags = t.tags || {}, this.traceId = t.traceId || this.traceId, this } getTraceContext() { return F({ data: Object.keys(this.data).length > 0 ? this.data : void 0, description: this.description, op: this.op, parent_span_id: this.parentSpanId, span_id: this.spanId, status: this.status, tags: Object.keys(this.tags).length > 0 ? this.tags : void 0, trace_id: this.traceId }) } toJSON() { return F({ data: Object.keys(this.data).length > 0 ? this.data : void 0, description: this.description, op: this.op, parent_span_id: this.parentSpanId, span_id: this.spanId, start_timestamp: this.startTimestamp, status: this.status, tags: Object.keys(this.tags).length > 0 ? this.tags : void 0, timestamp: this.endTimestamp, trace_id: this.traceId }) } } class pe extends fe { __init() { this.J = {} } __init2() { this.C = {} } __init3() { this.K = void 0 } constructor(t, e) { super(t), pe.prototype.__init.call(this), pe.prototype.__init2.call(this), pe.prototype.__init3.call(this), this.Y = e || se(), this.V = t.name || "", this.metadata = { source: "custom", ...t.metadata, spanMetadata: {} }, this.tt = t.trimEnd, this.transaction = this; const n = this.metadata.dynamicSamplingContext; n && (this.K = { ...n }) } get name() { return this.V } set name(t) { this.setName(t) } setName(t, e = "custom") { this.V = t, this.metadata.source = e } initSpanRecorder(t = 1e3) { this.spanRecorder || (this.spanRecorder = new de(t)), this.spanRecorder.add(this) } setContext(t, e) { null === e ? delete this.C[t] : this.C[t] = e } setMeasurement(t, e, n = "") { this.J[t] = { value: e, unit: n } } setMetadata(t) { this.metadata = { ...this.metadata, ...t } } finish(t) { if (void 0 !== this.endTimestamp) return; this.name || (this.name = "<unlabeled transaction>"), super.finish(t); const e = this.Y.getClient(); if (e && e.emit && e.emit("finishTransaction", this), !0 !== this.sampled) return void (e && e.recordDroppedEvent("sample_rate", "transaction")); const n = this.spanRecorder ? this.spanRecorder.spans.filter((t => t !== this && t.endTimestamp)) : []; this.tt && n.length > 0 && (this.endTimestamp = n.reduce(((t, e) => t.endTimestamp && e.endTimestamp ? t.endTimestamp > e.endTimestamp ? t : e : t)).endTimestamp); const i = this.metadata, r = { contexts: { ...this.C, trace: this.getTraceContext() }, spans: n, start_timestamp: this.startTimestamp, tags: this.tags, timestamp: this.endTimestamp, transaction: this.name, type: "transaction", sdkProcessingMetadata: { ...i, dynamicSamplingContext: this.getDynamicSamplingContext() }, ...i.source && { transaction_info: { source: i.source } } }; return Object.keys(this.J).length > 0 && (r.measurements = this.J), this.Y.captureEvent(r) } toContext() { return F({ ...super.toContext(), name: this.name, trimEnd: this.tt }) } updateWithContext(t) { return super.updateWithContext(t), this.name = t.name || "", this.tt = t.trimEnd, this } getDynamicSamplingContext() { if (this.K) return this.K; const t = this.Y || se(), e = t && t.getClient(); if (!e) return {}; const { environment: n, release: i } = e.getOptions() || {}, { publicKey: r } = e.getDsn() || {}, s = this.metadata.sampleRate, a = void 0 !== s ? s.toString() : void 0, { segment: o } = t.getScope().getUser() || {}, c = this.metadata.source, u = c && "url" !== c ? this.name : void 0, h = F({ environment: n || Jt, release: i, transaction: u, user_segment: o, public_key: r, trace_id: this.traceId, sample_rate: a }); return e.emit && e.emit("createDsc", h), h } setHub(t) { this.Y = t } } const me = { idleTimeout: 1e3, finalTimeout: 3e4, heartbeatInterval: 5e3 }, _e = ["heartbeatFailed", "idleTimeout", "documentHidden", "finalTimeout", "externalFinish", "cancelled"]; class ye extends de { constructor(t, e, n, i) { super(i), this.et = t, this.nt = e, this.transactionSpanId = n } add(t) { t.spanId !== this.transactionSpanId && (t.finish = e => { t.endTimestamp = "number" == typeof e ? e : Ot(), this.nt(t.spanId) }, void 0 === t.endTimestamp && this.et(t.spanId)), super.add(t) } } class ge extends pe { __init() { this.activities = {} } __init2() { this.it = 0 } __init3() { this.rt = !1 } __init4() { this.st = !1 } __init5() { this.ot = [] } __init6() { this.ct = _e[4] } constructor(t, e, n = me.idleTimeout, i = me.finalTimeout, r = me.heartbeatInterval, s = !1) { super(t, e), this.ut = e, this.ht = n, this.lt = i, this.dt = r, this.ft = s, ge.prototype.__init.call(this), ge.prototype.__init2.call(this), ge.prototype.__init3.call(this), ge.prototype.__init4.call(this), ge.prototype.__init5.call(this), ge.prototype.__init6.call(this), s && e.configureScope((t => t.setSpan(this))), this._t(), setTimeout((() => { this.rt || (this.setStatus("deadline_exceeded"), this.ct = _e[3], this.finish()) }), this.lt) } finish(t = Ot()) { if (this.rt = !0, this.activities = {}, "ui.action.click" === this.op && this.setTag("finishReason", this.ct), this.spanRecorder) { for (const e of this.ot) e(this, t); this.spanRecorder.spans = this.spanRecorder.spans.filter((e => { if (e.spanId === this.spanId) return !0; e.endTimestamp || (e.endTimestamp = t, e.setStatus("cancelled")); return e.startTimestamp < t })) } if (this.ft) { const t = this.ut.getScope(); t.getTransaction() === this && t.setSpan(void 0) } return super.finish(t) } registerBeforeFinishCallback(t) { this.ot.push(t) } initSpanRecorder(t) { if (!this.spanRecorder) { const e = t => { this.rt || this.et(t) }, n = t => { this.rt || this.nt(t) }; this.spanRecorder = new ye(e, n, this.spanId, t), this.yt() } this.spanRecorder.add(this) } cancelIdleTimeout(t, { restartOnChildSpanChange: e } = { restartOnChildSpanChange: !0 }) { this.st = !1 === e, this.gt && (clearTimeout(this.gt), this.gt = void 0, 0 === Object.keys(this.activities).length && this.st && (this.ct = _e[5], this.finish(t))) } setFinishReason(t) { this.ct = t } _t(t) { this.cancelIdleTimeout(), this.gt = setTimeout((() => { this.rt || 0 !== Object.keys(this.activities).length || (this.ct = _e[1], this.finish(t)) }), this.ht) } et(t) { this.cancelIdleTimeout(void 0, { restartOnChildSpanChange: !this.st }), this.activities[t] = !0 } nt(t) { if (this.activities[t] && delete this.activities[t], 0 === Object.keys(this.activities).length) { const t = Ot(); this.st ? (this.ct = _e[5], this.finish(t)) : this._t(t + this.ht / 1e3) } } bt() { if (this.rt) return; const t = Object.keys(this.activities).join(""); t === this.wt ? this.it++ : this.it = 1, this.wt = t, this.it >= 3 ? (this.setStatus("deadline_exceeded"), this.ct = _e[0], this.finish()) : this.yt() } yt() { setTimeout((() => { this.bt() }), this.dt) } } function be() { const t = this.getScope().getSpan(); return t ? { "sentry-trace": t.toTraceparent() } : {} } function we(t, e, n) { if (!ce(e)) return t.sampled = !1, t; if (void 0 !== t.sampled) return t.setMetadata({ sampleRate: Number(t.sampled) }), t; let i; return "function" == typeof e.tracesSampler ? (i = e.tracesSampler(n), t.setMetadata({ sampleRate: Number(i) })) : void 0 !== n.parentSampled ? i = n.parentSampled : void 0 !== e.tracesSampleRate ? (i = e.tracesSampleRate, t.setMetadata({ sampleRate: Number(i) })) : (i = 1, t.setMetadata({ sampleRate: i })), function (t) { if (l(t) || "number" != typeof t && "boolean" != typeof t) return !1; if (t < 0 || t > 1) return !1; return !0 }(i) && i ? (t.sampled = Math.random() < i, t.sampled, t) : (t.sampled = !1, t) } function ve(t, e) { const n = this.getClient(), i = n && n.getOptions() || {}; (i.instrumenter || "sentry") !== (t.instrumenter || "sentry") && (t.sampled = !1); let r = new pe(t, this); return r = we(r, i, { parentSampled: t.parentSampled, transactionContext: t, ...e }), r.sampled && r.initSpanRecorder(i._experiments && i._experiments.maxSpans), n && n.emit && n.emit("startTransaction", r), r } function ke(t, e, n, i, r, s, a) { const o = t.getClient(), c = o && o.getOptions() || {}; let u = new ge(e, t, n, i, a, r); return u = we(u, c, { parentSampled: e.parentSampled, transactionContext: e, ...s }), u.sampled && u.initSpanRecorder(c._experiments && c._experiments.maxSpans), o && o.emit && o.emit("startTransaction", u), u } function Se() { const t = ie(); t.__SENTRY__ && (t.__SENTRY__.extensions = t.__SENTRY__.extensions || {}, t.__SENTRY__.extensions.startTransaction || (t.__SENTRY__.extensions.startTransaction = ve), t.__SENTRY__.extensions.traceHeaders || (t.__SENTRY__.extensions.traceHeaders = be), he || (he = !0, V("error", le), V("unhandledrejection", le))) } function captureException(t, e) { return se().captureException(t, { captureContext: e }) } function xe(t, e) { se().setContext(t, e) } function Te(t) { se().withScope(t) } function Ee(t) { const e = t.protocol ? `${t.protocol}:` : "", n = t.port ? `:${t.port}` : ""; return `${e}//${t.host}${n}${t.path ? `/${t.path}` : ""}/api/` } function Ie(t, e) { return n = { sentry_key: t.publicKey, sentry_version: "7", ...e && { sentry_client: `${e.name}/${e.version}` } }, Object.keys(n).map((t => `${encodeURIComponent(t)}=${encodeURIComponent(n[t])}`)).join("&"); var n } function Ae(t, e = {}) { const n = "string" == typeof e ? e : e.tunnel, i = "string" != typeof e && e.vt ? e.vt.sdk : void 0; return n || `${function (t) { return `${Ee(t)}${t.projectId}/envelope/` }(t)}?${Ie(t, i)}` } const Ce = []; function Oe(t) { const e = t.defaultIntegrations || [], n = t.integrations; let i; e.forEach((t => { t.isDefaultInstance = !0 })), i = Array.isArray(n) ? [...e, ...n] : "function" == typeof n ? pt(n(e)) : e; const r = function (t) { const e = {}; return t.forEach((t => { const { name: n } = t, i = e[n]; i && !i.isDefaultInstance && t.isDefaultInstance || (e[n] = t) })), Object.keys(e).map((t => e[t])) }(i), s = function (t, e) { for (let n = 0; n < t.length; n++)if (!0 === e(t[n])) return n; return -1 }(r, (t => "Debug" === t.name)); if (-1 !== s) { const [t] = r.splice(s, 1); r.push(t) } return r } function Re(t, e) { e[t.name] = t, -1 === Ce.indexOf(t.name) && (t.setupOnce(te, se), Ce.push(t.name)) } function ze(t, e, n, i) { const { normalizeDepth: r = 3, normalizeMaxBreadth: s = 1e3 } = t, a = { ...e, event_id: e.event_id || n.event_id || ct(), timestamp: e.timestamp || Ct() }, o = n.integrations || t.integrations.map((t => t.name)); !function (t, e) { const { environment: n, release: i, dist: r, maxValueLength: s = 250 } = e; "environment" in t || (t.environment = "environment" in e ? n : Jt); void 0 === t.release && void 0 !== i && (t.release = i); void 0 === t.dist && void 0 !== r && (t.dist = r); t.message && (t.message = E(t.message, s)); const a = t.exception && t.exception.values && t.exception.values[0]; a && a.value && (a.value = E(a.value, s)); const o = t.request; o && o.url && (o.url = E(o.url, s)) }(a, t), function (t, e) { e.length > 0 && (t.sdk = t.sdk || {}, t.sdk.integrations = [...t.sdk.integrations || [], ...e]) }(a, o), void 0 === e.type && function (t, e) { const n = p.kt; if (!n) return; let i; const r = De.get(e); r ? i = r : (i = new Map, De.set(e, i)); const s = Object.keys(n).reduce(((t, r) => { let s; const a = i.get(r); a ? s = a : (s = e(r), i.set(r, s)); for (let e = s.length - 1; e >= 0; e--) { const i = s[e]; if (i.filename) { t[i.filename] = n[r]; break } } return t }), {}), a = new Set; try { t.exception.values.forEach((t => { t.stacktrace.frames.forEach((t => { t.filename && a.add(t.filename) })) })) } catch (t) { } t.debug_meta = t.debug_meta || {}, t.debug_meta.images = t.debug_meta.images || []; const o = t.debug_meta.images; a.forEach((t => { s[t] && o.push({ type: "sourcemap", code_file: t, debug_id: s[t] }) })) }(a, t.stackParser); let c = i; n.captureContext && (c = Vt.clone(c).update(n.captureContext)); let u = bt(a); if (c) { if (c.getAttachments) { const t = [...n.attachments || [], ...c.getAttachments()]; t.length && (n.attachments = t) } u = c.applyToEvent(a, n) } return u.then((t => "number" == typeof r && r > 0 ? function (t, e, n) { if (!t) return null; const i = { ...t, ...t.breadcrumbs && { breadcrumbs: t.breadcrumbs.map((t => ({ ...t, ...t.data && { data: mt(t.data, e, n) } }))) }, ...t.user && { user: mt(t.user, e, n) }, ...t.contexts && { contexts: mt(t.contexts, e, n) }, ...t.extra && { extra: mt(t.extra, e, n) } }; t.contexts && t.contexts.trace && i.contexts && (i.contexts.trace = t.contexts.trace, t.contexts.trace.data && (i.contexts.trace.data = mt(t.contexts.trace.data, e, n))); t.spans && (i.spans = t.spans.map((t => (t.data && (t.data = mt(t.data, e, n)), t)))); return i }(t, r, s) : t)) } const De = new WeakMap; class Le { __init() { this._integrations = {} } __init2() { this.St = !1 } __init3() { this.xt = 0 } __init4() { this.Tt = {} } __init5() { this.Et = {} } constructor(t) { if (Le.prototype.__init.call(this), Le.prototype.__init2.call(this), Le.prototype.__init3.call(this), Le.prototype.__init4.call(this), Le.prototype.__init5.call(this), this.It = t, t.dsn) { this.At = x(t.dsn); const e = Ae(this.At, t); this.Ct = t.transport({ recordDroppedEvent: this.recordDroppedEvent.bind(this), ...t.transportOptions, url: e }) } } captureException(t, e, n) { if (ft(t)) return; let i = e && e.event_id; return this.Ot(this.eventFromException(t, e).then((t => this.Rt(t, e, n))).then((t => { i = t }))), i } captureMessage(t, e, n, i) { let r = n && n.event_id; const s = o(t) ? this.eventFromMessage(String(t), e, n) : this.eventFromException(t, n); return this.Ot(s.then((t => this.Rt(t, n, i))).then((t => { r = t }))), r } captureEvent(t, e, n) { if (e && e.originalException && ft(e.originalException)) return; let i = e && e.event_id; return this.Ot(this.Rt(t, e, n).then((t => { i = t }))), i } captureSession(t) { this.zt() && ("string" != typeof t.release || (this.sendSession(t), Yt(t, { init: !1 }))) } getDsn() { return this.At } getOptions() { return this.It } getSdkMetadata() { return this.It.vt } getTransport() { return this.Ct } flush(t) { const e = this.Ct; return e ? this.Dt(t).then((n => e.flush(t).then((t => n && t)))) : bt(!0) } close(t) { return this.flush(t).then((t => (this.getOptions().enabled = !1, t))) } setupIntegrations() { this.zt() && !this.St && (this._integrations = function (t) { const e = {}; return t.forEach((t => { t && Re(t, e) })), e }(this.It.integrations), this.St = !0) } getIntegrationById(t) { return this._integrations[t] } getIntegration(t) { try { return this._integrations[t.id] || null } catch (t) { return null } } addIntegration(t) { Re(t, this._integrations) } sendEvent(t, e = {}) { if (this.At) { let n = function (t, e, n, i) { const r = Bt(n), s = t.type && "replay_event" !== t.type ? t.type : "event"; !function (t, e) { e && (t.sdk = t.sdk || {}, t.sdk.name = t.sdk.name || e.name, t.sdk.version = t.sdk.version || e.version, t.sdk.integrations = [...t.sdk.integrations || [], ...e.integrations || []], t.sdk.packages = [...t.sdk.packages || [], ...e.packages || []]) }(t, n && n.sdk); const a = Ht(t, r, i, e); return delete t.sdkProcessingMetadata, Dt(a, [[{ type: s }, t]]) }(t, this.At, this.It.vt, this.It.tunnel); for (const t of e.attachments || []) n = Lt(n, Ft(t, this.It.transportOptions && this.It.transportOptions.textEncoder)); const i = this.Lt(n); i && i.then((e => this.emit("afterSendEvent", t, e)), null) } } sendSession(t) { if (this.At) { const e = function (t, e, n, i) { const r = Bt(n); return Dt({ sent_at: (new Date).toISOString(), ...r && { sdk: r }, ...!!i && { dsn: k(e) } }, ["aggregates" in t ? [{ type: "sessions" }, t] : [{ type: "session" }, t]]) }(t, this.At, this.It.vt, this.It.tunnel); this.Lt(e) } } recordDroppedEvent(t, e, n) { if (this.It.sendClientReports) { const n = `${t}:${e}`; this.Tt[n] = this.Tt[n] + 1 || 1 } } on(t, e) { this.Et[t] || (this.Et[t] = []), this.Et[t].push(e) } emit(t, ...e) { this.Et[t] && this.Et[t].forEach((t => t(...e))) } Mt(t, e) { let n = !1, i = !1; const r = e.exception && e.exception.values; if (r) { i = !0; for (const t of r) { const e = t.mechanism; if (e && !1 === e.handled) { n = !0; break } } } const s = "ok" === t.status; (s && 0 === t.errors || s && n) && (Yt(t, { ...n && { status: "crashed" }, errors: t.errors || Number(i || n) }), this.captureSession(t)) } Dt(t) { return new vt((e => { let n = 0; const i = setInterval((() => { 0 == this.xt ? (clearInterval(i), e(!0)) : (n += 1, t && n >= t && (clearInterval(i), e(!1))) }), 1) })) } zt() { return !1 !== this.getOptions().enabled && void 0 !== this.At } $t(t, e, n) { const i = this.getOptions(), r = Object.keys(this._integrations); return !e.integrations && r.length > 0 && (e.integrations = r), ze(i, t, e, n) } Rt(t, e = {}, n) { return this.Nt(t, e, n).then((t => t.event_id), (t => { })) } Nt(t, e, n) { const i = this.getOptions(), { sampleRate: r } = i; if (!this.zt()) return wt(new w("SDK not enabled, will not capture event.", "log")); const s = $e(t), a = Me(t), o = t.type || "error", u = `before send for type \`${o}\``; if (a && "number" == typeof r && Math.random() > r) return this.recordDroppedEvent("sample_rate", "error", t), wt(new w(`Discarding event because it's not included in the random sample (sampling rate = ${r})`, "log")); const l = "replay_event" === o ? "replay" : o; return this.$t(t, e, n).then((n => { if (null === n) throw this.recordDroppedEvent("event_processor", l, t), new w("An event processor returned `null`, will not send event.", "log"); if (e.data && !0 === e.data.__sentry__) return n; const r = function (t, e, n) { const { beforeSend: i, beforeSendTransaction: r } = t; if (Me(e) && i) return i(e, n); if ($e(e) && r) return r(e, n); return e }(i, n, e); return function (t, e) { const n = `${e} must return \`null\` or a valid event.`; if (h(t)) return t.then((t => { if (!c(t) && null !== t) throw new w(n); return t }), (t => { throw new w(`${e} rejected with ${t}`) })); if (!c(t) && null !== t) throw new w(n); return t }(r, u) })).then((i => { if (null === i) throw this.recordDroppedEvent("before_send", l, t), new w(`${u} returned \`null\`, will not send event.`, "log"); const r = n && n.getSession(); !s && r && this.Mt(r, i); const a = i.transaction_info; if (s && a && i.transaction !== t.transaction) { const t = "custom"; i.transaction_info = { ...a, source: t } } return this.sendEvent(i, e), i })).then(null, (t => { if (t instanceof w) throw t; throw this.captureException(t, { data: { __sentry__: !0 }, originalException: t }), new w(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${t}`) })) } Ot(t) { this.xt++, t.then((t => (this.xt--, t)), (t => (this.xt--, t))) } Lt(t) { if (this.Ct && this.At) return this.emit("beforeEnvelope", t), this.Ct.send(t).then(null, (t => { })) } Ft() { const t = this.Tt; return this.Tt = {}, Object.keys(t).map((e => { const [n, i] = e.split(":"); return { reason: n, category: i, quantity: t[e] } })) } } function Me(t) { return void 0 === t.type } function $e(t) { return "transaction" === t.type } function Ne(t, e, n = kt(t.bufferSize || 30)) { let i = {}; function r(r) { const s = []; if (Mt(r, ((e, n) => { const r = Ut(n); if (function (t, e, n = Date.now()) { return function (t, e) { return t[e] || t.all || 0 }(t, e) > n }(i, r)) { const i = Fe(e, n); t.recordDroppedEvent("ratelimit_backoff", r, i) } else s.push(e) })), 0 === s.length) return bt(); const a = Dt(r[0], s), o = e => { Mt(a, ((n, i) => { const r = Fe(n, i); t.recordDroppedEvent(e, Ut(i), r) })) }; return n.add((() => e({ body: Nt(a, t.textEncoder) }).then((t => (i = Zt(i, t), t)), (t => { throw o("network_error"), t })))).then((t => t), (t => { if (t instanceof w) return o("queue_overflow"), bt(); throw t })) } return r.__sentry__baseTransport__ = !0, { send: r, flush: t => n.drain(t) } } function Fe(t, e) { if ("event" === e || "transaction" === e) return Array.isArray(t) ? t[1] : void 0 } const je = "7.49.0"; let Ue; class Be { constructor() { Be.prototype.__init.call(this) } static __initStatic() { this.id = "FunctionToString" } __init() { this.name = Be.id } setupOnce() { Ue = Function.prototype.toString, Function.prototype.toString = function (...t) { const e = D(this) || this; return Ue.apply(e, t) } } } Be.__initStatic(); const He = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/]; class Ze { static __initStatic() { this.id = "InboundFilters" } __init() { this.name = Ze.id } constructor(t = {}) { this.It = t, Ze.prototype.__init.call(this) } setupOnce(t, e) { const n = t => { const n = e(); if (n) { const e = n.getIntegration(Ze); if (e) { const i = n.getClient(), r = i ? i.getOptions() : {}, s = function (t = {}, e = {}) { return { allowUrls: [...t.allowUrls || [], ...e.allowUrls || []], denyUrls: [...t.denyUrls || [], ...e.denyUrls || []], ignoreErrors: [...t.ignoreErrors || [], ...e.ignoreErrors || [], ...He], ignoreTransactions: [...t.ignoreTransactions || [], ...e.ignoreTransactions || []], ignoreInternal: void 0 === t.ignoreInternal || t.ignoreInternal } }(e.It, r); return function (t, e) { if (e.ignoreInternal && function (t) { try { return "SentryError" === t.exception.values[0].type } catch (t) { } return !1 }(t)) return !0; if (function (t, e) { if (t.type || !e || !e.length) return !1; return function (t) { if (t.message) return [t.message]; if (t.exception) try { const { type: e = "", value: n = "" } = t.exception.values && t.exception.values[0] || {}; return [`${n}`, `${e}: ${n}`] } catch (t) { return [] } return [] }(t).some((t => C(t, e))) }(t, e.ignoreErrors)) return !0; if (function (t, e) { if ("transaction" !== t.type || !e || !e.length) return !1; const n = t.transaction; return !!n && C(n, e) }(t, e.ignoreTransactions)) return !0; if (function (t, e) { if (!e || !e.length) return !1; const n = Pe(t); return !!n && C(n, e) }(t, e.denyUrls)) return !0; if (!function (t, e) { if (!e || !e.length) return !0; const n = Pe(t); return !n || C(n, e) }(t, e.allowUrls)) return !0; return !1 }(t, s) ? null : t } } return t }; n.id = this.name, t(n) } } function Pe(t) { try { let e; try { e = t.exception.values[0].stacktrace.frames } catch (t) { } return e ? function (t = []) { for (let e = t.length - 1; e >= 0; e--) { const n = t[e]; if (n && "<anonymous>" !== n.filename && "[native code]" !== n.filename) return n.filename || null } return null }(e) : null } catch (t) { return null } } Ze.__initStatic(); var qe = Object.freeze({ __proto__: null, FunctionToString: Be, InboundFilters: Ze }); const We = p; const Xe = (t, e, n) => { let i, r; return s => { e.value >= 0 && (s || n) && (r = e.value - (i || 0), (r || void 0 === i) && (i = e.value, e.delta = r, t(e))) } }, Ge = () => We.__WEB_VITALS_POLYFILL__ ? We.performance && (performance.getEntriesByType && performance.getEntriesByType("navigation")[0] || (() => { const t = We.performance.timing, e = We.performance.navigation.type, n = { entryType: "navigation", startTime: 0, type: 2 == e ? "back_forward" : 1 === e ? "reload" : "navigate" }; for (const e in t) "navigationStart" !== e && "toJSON" !== e && (n[e] = Math.max(t[e] - t.navigationStart, 0)); return n })()) : We.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0], Je = () => { const t = Ge(); return t && t.activationStart || 0 }, Ke = (t, e) => { const n = Ge(); let i = "navigate"; return n && (i = We.document.prerendering || Je() > 0 ? "prerender" : n.type.replace(/_/g, "-")), { name: t, value: void 0 === e ? -1 : e, rating: "good", delta: 0, entries: [], id: `v3-${Date.now()}-${Math.floor(8999999999999 * Math.random()) + 1e12}`, navigationType: i } }, Ye = (t, e, n) => { try { if (PerformanceObserver.supportedEntryTypes.includes(t)) { const i = new PerformanceObserver((t => { e(t.getEntries()) })); return i.observe(Object.assign({ type: t, buffered: !0 }, n || {})), i } } catch (t) { } }, Ve = (t, e) => { const n = i => { "pagehide" !== i.type && "hidden" !== We.document.visibilityState || (t(i), e && (removeEventListener("visibilitychange", n, !0), removeEventListener("pagehide", n, !0))) }; addEventListener("visibilitychange", n, !0), addEventListener("pagehide", n, !0) }; let Qe = -1; const tn = () => (Qe < 0 && (Qe = "hidden" !== We.document.visibilityState || We.document.prerendering ? 1 / 0 : 0, Ve((({ timeStamp: t }) => { Qe = t }), !0)), { get firstHiddenTime() { return Qe } }), en = {}; function nn(t) { return "number" == typeof t && isFinite(t) } function rn(t, { startTimestamp: e, ...n }) { return e && t.startTimestamp > e && (t.startTimestamp = e), t.startChild({ startTimestamp: e, ...n }) } function sn(t) { return t / 1e3 } function an() { return We && We.addEventListener && We.performance } let on, cn, un = 0, hn = {}; function ln() { const t = an(); if (t && Rt) { t.mark && We.performance.mark("sentry-tracing-init"), (t => { const e = tn(), n = Ke("FID"); let i; const r = t => { t.startTime < e.firstHiddenTime && (n.value = t.processingStart - t.startTime, n.entries.push(t), i(!0)) }, s = t => { t.forEach(r) }, a = Ye("first-input", s); i = Xe(t, n), a && Ve((() => { s(a.takeRecords()), a.disconnect() }), !0) })((t => { const e = t.entries.pop(); if (!e) return; const n = sn(Rt), i = sn(e.startTime); hn.fid = { value: t.value, unit: "millisecond" }, hn["mark.fid"] = { value: n + i, unit: "second" } })); const e = (t => { const e = Ke("CLS", 0); let n, i = 0, r = []; const s = t => { t.forEach((t => { if (!t.hadRecentInput) { const s = r[0], a = r[r.length - 1]; i && 0 !== r.length && t.startTime - a.startTime < 1e3 && t.startTime - s.startTime < 5e3 ? (i += t.value, r.push(t)) : (i = t.value, r = [t]), i > e.value && (e.value = i, e.entries = r, n && n()) } })) }, a = Ye("layout-shift", s); if (a) { n = Xe(t, e); const i = () => { s(a.takeRecords()), n(!0) }; return Ve(i), i } })((t => { const e = t.entries.pop(); e && (hn.cls = { value: t.value, unit: "" }, cn = e) })), n = (t => { const e = tn(), n = Ke("LCP"); let i; const r = t => { const r = t[t.length - 1]; if (r) { const t = Math.max(r.startTime - Je(), 0); t < e.firstHiddenTime && (n.value = t, n.entries = [r], i()) } }, s = Ye("largest-contentful-paint", r); if (s) { i = Xe(t, n); const e = () => { en[n.id] || (r(s.takeRecords()), s.disconnect(), en[n.id] = !0, i(!0)) }; return ["keydown", "click"].forEach((t => { addEventListener(t, e, { once: !0, capture: !0 }) })), Ve(e, !0), e } })((t => { const e = t.entries.pop(); e && (hn.lcp = { value: t.value, unit: "millisecond" }, on = e) })); return () => { e && e(), n && n() } } return () => { } } function dn(t) { const e = an(); if (!e || !We.performance.getEntries || !Rt) return; const n = sn(Rt), i = e.getEntries(); let r, s; if (i.slice(un).forEach((e => { const i = sn(e.startTime), a = sn(e.duration); if (!("navigation" === t.op && n + i < t.startTimestamp)) switch (e.entryType) { case "navigation": !function (t, e, n) { ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((i => { fn(t, e, i, n) })), fn(t, e, "secureConnection", n, "TLS/SSL", "connectEnd"), fn(t, e, "fetch", n, "cache", "domainLookupStart"), fn(t, e, "domainLookup", n, "DNS"), function (t, e, n) { rn(t, { op: "browser", description: "request", startTimestamp: n + sn(e.requestStart), endTimestamp: n + sn(e.responseEnd) }), rn(t, { op: "browser", description: "response", startTimestamp: n + sn(e.responseStart), endTimestamp: n + sn(e.responseEnd) }) }(t, e, n) }(t, e, n), r = n + sn(e.responseStart), s = n + sn(e.requestStart); break; case "mark": case "paint": case "measure": { !function (t, e, n, i, r) { const s = r + n, a = s + i; rn(t, { description: e.name, endTimestamp: a, op: e.entryType, startTimestamp: s }) }(t, e, i, a, n); const r = tn(), s = e.startTime < r.firstHiddenTime; "first-paint" === e.name && s && (hn.fp = { value: e.startTime, unit: "millisecond" }), "first-contentful-paint" === e.name && s && (hn.fcp = { value: e.startTime, unit: "millisecond" }); break } case "resource": { const r = e.name.replace(We.location.origin, ""); !function (t, e, n, i, r, s) { if ("xmlhttprequest" === e.initiatorType || "fetch" === e.initiatorType) return; const a = {}; "transferSize" in e && (a["Transfer Size"] = e.transferSize); "encodedBodySize" in e && (a["Encoded Body Size"] = e.encodedBodySize); "decodedBodySize" in e && (a["Decoded Body Size"] = e.decodedBodySize); "renderBlockingStatus" in e && (a["resource.render_blocking_status"] = e.renderBlockingStatus); const o = s + i; rn(t, { description: n, endTimestamp: o + r, op: e.initiatorType ? `resource.${e.initiatorType}` : "resource.other", startTimestamp: o, data: a }) }(t, e, r, i, a, n); break } } })), un = Math.max(i.length - 1, 0), function (t) { const e = We.navigator; if (!e) return; const n = e.connection; n && (n.effectiveType && t.setTag("effectiveConnectionType", n.effectiveType), n.type && t.setTag("connectionType", n.type), nn(n.rtt) && (hn["connection.rtt"] = { value: n.rtt, unit: "millisecond" })); nn(e.deviceMemory) && t.setTag("deviceMemory", `${e.deviceMemory} GB`); nn(e.hardwareConcurrency) && t.setTag("hardwareConcurrency", String(e.hardwareConcurrency)) }(t), "pageload" === t.op) { "number" == typeof r && (hn.ttfb = { value: 1e3 * (r - t.startTimestamp), unit: "millisecond" }, "number" == typeof s && s <= r && (hn["ttfb.requestTime"] = { value: 1e3 * (r - s), unit: "millisecond" })), ["fcp", "fp", "lcp"].forEach((e => { if (!hn[e] || n >= t.startTimestamp) return; const i = hn[e].value, r = n + sn(i), s = Math.abs(1e3 * (r - t.startTimestamp)); hn[e].value = s })); const e = hn["mark.fid"]; e && hn.fid && (rn(t, { description: "first input delay", endTimestamp: e.value + sn(hn.fid.value), op: "ui.action", startTimestamp: e.value }), delete hn["mark.fid"]), "fcp" in hn || delete hn.cls, Object.keys(hn).forEach((e => { t.setMeasurement(e, hn[e].value, hn[e].unit) })), function (t) { on && (on.element && t.setTag("lcp.element", g(on.element)), on.id && t.setTag("lcp.id", on.id), on.url && t.setTag("lcp.url", on.url.trim().slice(0, 200)), t.setTag("lcp.size", on.size)); cn && cn.sources && cn.sources.forEach(((e, n) => t.setTag(`cls.source.${n + 1}`, g(e.node)))) }(t) } on = void 0, cn = void 0, hn = {} } function fn(t, e, n, i, r, s) { const a = s ? e[s] : e[`${n}End`], o = e[`${n}Start`]; o && a && rn(t, { op: "browser", description: r || n, startTimestamp: i + sn(o), endTimestamp: i + sn(a) }) } const pn = ["localhost", /^\//], mn = { traceFetch: !0, traceXHR: !0, tracingOrigins: pn, tracePropagationTargets: pn }; function _n(t) { const { traceFetch: e, traceXHR: n, tracePropagationTargets: i, tracingOrigins: r, shouldCreateSpanForRequest: s } = { traceFetch: mn.traceFetch, traceXHR: mn.traceXHR, ...t }, a = "function" == typeof s ? s : t => !0, o = t => function (t, e) { return C(t, e || pn) }(t, i || r), c = {}; e && V("fetch", (t => { !function (t, e, n, i) { if (!ce() || !t.fetchData || !e(t.fetchData.url)) return; if (t.endTimestamp) { const e = t.fetchData.__span; if (!e) return; const n = i[e]; return void (n && (t.response ? n.setHttpStatus(t.response.status) : t.error && n.setStatus("internal_error"), n.finish(), delete i[e])) } const r = se().getScope(), s = r && r.getSpan(), a = s && s.transaction; if (s && a) { const e = s.startChild({ data: { ...t.fetchData, type: "fetch" }, description: `${t.fetchData.method} ${t.fetchData.url}`, op: "http.client" }); t.fetchData.__span = e.spanId, i[e.spanId] = e; const r = t.args[0]; t.args[1] = t.args[1] || {}; const o = t.args[1]; n(t.fetchData.url) && (o.headers = function (t, e, n, i) { const r = Xt(e), s = n.toTraceparent(), a = "undefined" != typeof Request && d(t, Request) ? t.headers : i.headers; if (a) { if ("undefined" != typeof Headers && d(a, Headers)) { const t = new Headers(a); return t.append("sentry-trace", s), r && t.append(Pt, r), t } if (Array.isArray(a)) { const t = [...a, ["sentry-trace", s]]; return r && t.push([Pt, r]), t } { const t = "baggage" in a ? a.baggage : void 0, e = []; return Array.isArray(t) ? e.push(...t) : t && e.push(t), r && e.push(r), { ...a, "sentry-trace": s, baggage: e.length > 0 ? e.join(",") : void 0 } } } return { "sentry-trace": s, baggage: r } }(r, a.getDynamicSamplingContext(), e, o)) } }(t, a, o, c) })), n && V("xhr", (t => { !function (t, e, n, i) { const r = t.xhr, s = r && r.__sentry_xhr_v2__; if (!ce() || r && r.__sentry_own_request__ || !(r && s && e(s.url))) return; if (t.endTimestamp) { const t = r.__sentry_xhr_span_id__; if (!t) return; const e = i[t]; return void (e && (e.setHttpStatus(s.status_code), e.finish(), delete i[t])) } const a = se().getScope(), o = a && a.getSpan(), c = o && o.transaction; if (o && c) { const t = o.startChild({ data: { ...s.data, type: "xhr", method: s.method, url: s.url }, description: `${s.method} ${s.url}`, op: "http.client" }); if (r.__sentry_xhr_span_id__ = t.spanId, i[r.__sentry_xhr_span_id__] = t, r.setRequestHeader && n(s.url)) try { r.setRequestHeader("sentry-trace", t.toTraceparent()); const e = Xt(c.getDynamicSamplingContext()); e && r.setRequestHeader(Pt, e) } catch (t) { } } }(t, a, o, c) })) } const yn = { ...me, markBackgroundTransactions: !0, routingInstrumentation: function (t, e = !0, n = !0) { if (!We || !We.location) return; let i, r = We.location.href; e && (i = t({ name: We.location.pathname, startTimestamp: Rt ? Rt / 1e3 : void 0, op: "pageload", metadata: { source: "url" } })), n && V("history", (({ to: e, from: n }) => { void 0 === n && r && -1 !== r.indexOf(e) ? r = void 0 : n !== e && (r = void 0, i && i.finish(), i = t({ name: We.location.pathname, op: "navigation", metadata: { source: "url" } })) })) }, startTransactionOnLocationChange: !0, startTransactionOnPageLoad: !0, enableLongTask: !0, _experiments: {}, ...mn }; class gn { __init() { this.name = "BrowserTracing" } constructor(t) { gn.prototype.__init.call(this), Se(), this.options = { ...yn, ...t }, void 0 !== this.options._experiments.enableLongTask && (this.options.enableLongTask = this.options._experiments.enableLongTask), t && !t.tracePropagationTargets && t.tracingOrigins && (this.options.tracePropagationTargets = t.tracingOrigins), this.jt = ln(), this.options.enableLongTask && Ye("longtask", (t => { for (const e of t) { const t = ue(); if (!t) return; const n = sn(Rt + e.startTime), i = sn(e.duration); t.startChild({ description: "Main UI thread blocked", op: "ui.long-task", startTimestamp: n, endTimestamp: n + i }) } })), this.options._experiments.enableInteractions && Ye("event", (t => { for (const e of t) { const t = ue(); if (!t) return; if ("click" === e.name) { const n = sn(Rt + e.startTime), i = sn(e.duration); t.startChild({ description: g(e.target), op: `ui.interaction.${e.name}`, startTimestamp: n, endTimestamp: n + i }) } } }), { durationThreshold: 0 }) } setupOnce(t, e) { this.Ut = e; const { routingInstrumentation: n, startTransactionOnLocationChange: i, startTransactionOnPageLoad: r, markBackgroundTransactions: s, traceFetch: a, traceXHR: o, tracePropagationTargets: c, shouldCreateSpanForRequest: u, _experiments: h } = this.options; n((t => { const n = this.Bt(t); return this.options._experiments.onStartRouteTransaction && this.options._experiments.onStartRouteTransaction(n, t, e), n }), r, i), s && We && We.document && We.document.addEventListener("visibilitychange", (() => { const t = ue(); if (We.document.hidden && t) { const e = "cancelled"; t.status || t.setStatus(e), t.setTag("visibilitychange", "document.hidden"), t.finish() } })), h.enableInteractions && this.Ht(), _n({ traceFetch: a, traceXHR: o, tracePropagationTargets: c, shouldCreateSpanForRequest: u }) } Bt(t) { if (!this.Ut) return; const { beforeNavigate: e, idleTimeout: n, finalTimeout: i, heartbeatInterval: r } = this.options, s = "pageload" === t.op, o = s ? bn("sentry-trace") : null, c = s ? bn("baggage") : null, u = o ? function (t) { const e = t.match(zt); if (!t || !e) return; let n; return "1" === e[3] ? n = !0 : "0" === e[3] && (n = !1), { traceId: e[1], parentSampled: n, parentSpanId: e[2] } }(o) : void 0, h = c ? function (t) { if (!a(t) && !Array.isArray(t)) return; let e = {}; if (Array.isArray(t)) e = t.reduce(((t, e) => ({ ...t, ...Gt(e) })), {}); else { if (!t) return; e = Gt(t) } const n = Object.entries(e).reduce(((t, [e, n]) => (e.match(Wt) && (t[e.slice(qt.length)] = n), t)), {}); return Object.keys(n).length > 0 ? n : void 0 }(c) : void 0, l = { ...t, ...u, metadata: { ...t.metadata, dynamicSamplingContext: u && !h ? {} : h }, trimEnd: !0 }, d = "function" == typeof e ? e(l) : l, f = void 0 === d ? { ...l, sampled: !1 } : d; f.metadata = f.name !== l.name ? { ...f.metadata, source: "custom" } : f.metadata, this.Zt = f.name, this.Pt = f.metadata && f.metadata.source; const p = this.Ut(), { location: m } = We, _ = ke(p, f, n, i, !0, { location: m }, r); return _.registerBeforeFinishCallback((t => { this.jt(), dn(t) })), _ } Ht() { let t; const e = () => { const { idleTimeout: e, finalTimeout: n, heartbeatInterval: i } = this.options, r = ue(); if (r && r.op && ["navigation", "pageload"].includes(r.op)) return; if (t && (t.setFinishReason("interactionInterrupted"), t.finish(), t = void 0), !this.Ut) return; if (!this.Zt) return; const s = this.Ut(), { location: a } = We, o = { name: this.Zt, op: "ui.action.click", trimEnd: !0, metadata: { source: this.Pt || "url" } }; t = ke(s, o, e, n, !0, { location: a }, i) };["click"].forEach((t => { addEventListener(t, e, { once: !1, capture: !0 }) })) } } function bn(t) { const e = (n = `meta[name=${t}]`, y.document && y.document.querySelector ? y.document.querySelector(n) : null); var n; return e ? e.getAttribute("content") : null } function wn() { Se() } const vn = p, kn = "sentryReplaySession", Sn = "Unable to send Replay", xn = 15e4; var Tn; function En(t) { const e = null == t ? void 0 : t.host; return Boolean(e && e.shadowRoot && e.shadowRoot === t) } function In({ maskInputOptions: t, tagName: e, type: n }) { "option" === e.toLowerCase() && (e = "select"); const i = "string" == typeof n ? n.toLowerCase() : void 0; return t[e.toLowerCase()] || i && t[i] || "password" === i || "input" === e && !n && t.text } function An({ input: t, maskInputSelector: e, unmaskInputSelector: n, maskInputOptions: i, tagName: r, type: s, value: a, maskInputFn: o }) { let c = a || ""; return n && t.matches(n) || (t.hasAttribute("rr_is_password") && (s = "password"), (In({ maskInputOptions: i, tagName: r, type: s }) || e && t.matches(e)) && (c = o ? o(c) : "*".repeat(c.length))), c } !function (t) { t[t.Document = 0] = "Document", t[t.DocumentType = 1] = "DocumentType", t[t.Element = 2] = "Element", t[t.Text = 3] = "Text", t[t.CDATA = 4] = "CDATA", t[t.Comment = 5] = "Comment" }(Tn || (Tn = {})); const Cn = "__rrweb_original__"; let On = 1; const Rn = new RegExp("[^a-z0-9-_:]"); function zn(t) { return t ? t.replace(/[\S]/g, "*") : "" } function Dn(t) { try { const e = t.rules || t.cssRules; return e ? Array.from(e).map(Ln).join("") : null } catch (t) { return null } } function Ln(t) { let e = t.cssText; if (function (t) { return "styleSheet" in t }(t)) try { e = Dn(t.styleSheet) || e } catch (t) { } return e } let Mn, $n; const Nn = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm, Fn = /^(?!www\.|(?:http|ftp)s?:\/\/|[A-Za-z]:\\|\/\/|#).*/, jn = /^(data:)([^,]*),(.*)/i; function Un(t, e) { return (t || "").replace(Nn, ((t, n, i, r, s, a) => { const o = i || s || a, c = n || r || ""; if (!o) return t; if (!Fn.test(o)) return `url(${c}${o}${c})`; if (jn.test(o)) return `url(${c}${o}${c})`; if ("/" === o[0]) return `url(${c}${function (t) { let e = ""; return e = t.indexOf("//") > -1 ? t.split("/").slice(0, 3).join("/") : t.split("/")[0], e = e.split("?")[0], e }(e) + o}${c})`; const u = e.split("/"), h = o.split("/"); u.pop(); for (const t of h) "." !== t && (".." === t ? u.pop() : u.push(t)); return `url(${c}${u.join("/")}${c})` })) } const Bn = /^[^ \t\n\r\u000c]+/, Hn = /^[, \t\n\r\u000c]+/; function Zn(t, e) { if (!e || "" === e.trim()) return e; const n = t.createElement("a"); return n.href = e, n.href } function Pn() { const t = document.createElement("a"); return t.href = "", t.href } function qn(t, e, n, i, r, s, a, o) { if (!r) return r; const c = i.toLowerCase(), u = n.toLowerCase(); return "src" === c || "href" === c || "xlink:href" === c && "#" !== r[0] ? Zn(t, r) : "background" !== c || "table" !== u && "td" !== u && "th" !== u ? "srcset" === c ? function (t, e) { if ("" === e.trim()) return e; let n = 0; function i(t) { let i, r = t.exec(e.substring(n)); return r ? (i = r[0], n += i.length, i) : "" } let r = []; for (; i(Hn), !(n >= e.length);) { let s = i(Bn); if ("," === s.slice(-1)) s = Zn(t, s.substring(0, s.length - 1)), r.push(s); else { let i = ""; s = Zn(t, s); let a = !1; for (; ;) { let t = e.charAt(n); if ("" === t) { r.push((s + i).trim()); break } if (a) ")" === t && (a = !1); else { if ("," === t) { n += 1, r.push((s + i).trim()); break } "(" === t && (a = !0) } i += t, n += 1 } } } return r.join(", ") }(t, r) : "style" === c ? Un(r, Pn()) : "object" === u && "data" === c ? Zn(t, r) : s && function (t, e, n, i) { if (i && t.matches(i)) return !1; return ["placeholder", "title", "aria-label"].indexOf(e) > -1 || "input" === n && "value" === e && t.hasAttribute("type") && ["submit", "button"].indexOf(t.getAttribute("type").toLowerCase()) > -1 }(e, c, u, a) ? o ? o(r) : zn(r) : r : Zn(t, r) } function Wn(t, e, n, i, r) { if (!t) return !1; if (t.nodeType !== t.ELEMENT_NODE) return Wn(t.parentNode, e, n, i, r); if (i && (t.matches(i) || t.closest(i))) return !1; if (r) return !0; if ("string" == typeof e) { if (t.classList.contains(e)) return !0 } else for (let n = 0; n < t.classList.length; n++) { const i = t.classList[n]; if (e.test(i)) return !0 } return !(!n || !t.matches(n)) || Wn(t.parentNode, e, n, i, r) } function Xn(t, e) { var n; const { doc: i, blockClass: r, blockSelector: s, unblockSelector: a, maskTextClass: o, maskTextSelector: c, unmaskTextSelector: u, inlineStylesheet: h, maskInputSelector: l, unmaskInputSelector: d, maskAllText: f, maskInputOptions: p = {}, maskTextFn: m, maskInputFn: _, dataURLOptions: y = {}, inlineImages: g, recordCanvas: b, keepIframeSrcFn: w } = e; let v; if (i.__sn) { const t = i.__sn.id; v = 1 === t ? void 0 : t } switch (t.nodeType) { case t.DOCUMENT_NODE: return "CSS1Compat" !== t.compatMode ? { type: Tn.Document, childNodes: [], compatMode: t.compatMode, rootId: v } : { type: Tn.Document, childNodes: [], rootId: v }; case t.DOCUMENT_TYPE_NODE: return { type: Tn.DocumentType, name: t.name, publicId: t.publicId, systemId: t.systemId, rootId: v }; case t.ELEMENT_NODE: const e = function (t, e, n, i) { if (i && t.matches(i)) return !1; if ("string" == typeof e) { if (t.classList.contains(e)) return !0 } else for (let n = 0; n < t.classList.length; n++) { const i = t.classList[n]; if (e.test(i)) return !0 } return !!n && t.matches(n) }(t, r, s, a), x = function (t) { if (t instanceof HTMLFormElement) return "form"; const e = t.tagName.toLowerCase().trim(); return Rn.test(e) ? "div" : e }(t); let T = {}; for (const { name: e, value: n } of Array.from(t.attributes)) Kn(x, e) || (T[e] = qn(i, t, x, e, n, f, u, m)); if ("link" === x && h) { const e = Array.from(i.styleSheets).find((e => e.href === t.href)); let n = null; e && (n = Dn(e)), n && (delete T.rel, delete T.href, T._cssText = Un(n, e.href)) } if ("style" === x && t.sheet && !(t.innerText || t.textContent || "").trim().length) { const e = Dn(t.sheet); e && (T._cssText = Un(e, Pn())) } if ("input" === x || "textarea" === x || "select" === x || "option" === x) { const e = t, n = function (t, e, n) { if ("input" === t && ("radio" === n.type || "checkbox" === n.type)) return e.getAttribute("value") || ""; return e.value }(x, e, T), i = t.checked; "submit" !== T.type && "button" !== T.type && n && (T.value = An({ input: e, type: T.type, tagName: x, value: n, maskInputSelector: l, unmaskInputSelector: d, maskInputOptions: p, maskInputFn: _ })), i && (T.checked = i) } if ("option" === x && (t.selected && !p.select ? T.selected = !0 : delete T.selected), "canvas" === x && b) if ("2d" === t.__context) (function (t) { const e = t.getContext("2d"); if (!e) return !0; for (let n = 0; n < t.width; n += 50)for (let i = 0; i < t.height; i += 50) { const r = e.getImageData, s = Cn in r ? r.__rrweb_original__ : r; if (new Uint32Array(s.call(e, n, i, Math.min(50, t.width - n), Math.min(50, t.height - i)).data.buffer).some((t => 0 !== t))) return !1 } return !0 })(t) || (T.rr_dataURL = t.toDataURL(y.type, y.quality)); else if (!("__context" in t)) { const e = t.toDataURL(y.type, y.quality), n = document.createElement("canvas"); n.width = t.width, n.height = t.height; e !== n.toDataURL(y.type, y.quality) && (T.rr_dataURL = e) } if ("img" === x && g) { Mn || (Mn = i.createElement("canvas"), $n = Mn.getContext("2d")); const e = t, n = e.crossOrigin; e.crossOrigin = "anonymous"; const r = () => { try { Mn.width = e.naturalWidth, Mn.height = e.naturalHeight, $n.drawImage(e, 0, 0), T.rr_dataURL = Mn.toDataURL(y.type, y.quality) } catch (t) { console.warn(`Cannot inline img src=${e.currentSrc}! Error: ${t}`) } n ? T.crossOrigin = n : delete T.crossOrigin }; e.complete && 0 !== e.naturalWidth ? r() : e.onload = r } if ("audio" !== x && "video" !== x || (T.rr_mediaState = t.paused ? "paused" : "played", T.rr_mediaCurrentTime = t.currentTime), t.scrollLeft && (T.rr_scrollLeft = t.scrollLeft), t.scrollTop && (T.rr_scrollTop = t.scrollTop), e) { const { width: e, height: n } = t.getBoundingClientRect(); T = { class: T.class, rr_width: `${e}px`, rr_height: `${n}px` } } return "iframe" !== x || w(T.src) || (t.contentDocument || (T.rr_src = T.src), delete T.src), { type: Tn.Element, tagName: x, attributes: T, childNodes: [], isSVG: (S = t, Boolean("svg" === S.tagName || S.ownerSVGElement) || void 0), needBlock: e, rootId: v }; case t.TEXT_NODE: const E = t.parentNode && t.parentNode.tagName; let I = t.textContent; const A = "STYLE" === E || void 0, C = "SCRIPT" === E || void 0; if (A && I) { try { t.nextSibling || t.previousSibling || (null === (n = t.parentNode.sheet) || void 0 === n ? void 0 : n.cssRules) && (I = (k = t.parentNode.sheet).cssRules ? Array.from(k.cssRules).map((t => t.cssText || "")).join("") : "") } catch (e) { console.warn(`Cannot get CSS styles from text's parentNode. Error: ${e}`, t) } I = Un(I, Pn()) } if (C && (I = "SCRIPT_PLACEHOLDER"), "TEXTAREA" === E && I) I = ""; else if ("OPTION" === E && I) { I = An({ input: t.parentNode, type: null, tagName: E, value: I, maskInputSelector: l, unmaskInputSelector: d, maskInputOptions: p, maskInputFn: _ }) } else !A && !C && Wn(t, o, c, u, f) && I && (I = m ? m(I) : zn(I)); return { type: Tn.Text, textContent: I || "", isStyle: A, rootId: v }; case t.CDATA_SECTION_NODE: return { type: Tn.CDATA, textContent: "", rootId: v }; case t.COMMENT_NODE: return { type: Tn.Comment, textContent: t.textContent || "", rootId: v }; default: return !1 }var k, S } function Gn(t) { return null == t ? "" : t.toLowerCase() } function Jn(t, e) { const { doc: n, map: i, blockClass: r, blockSelector: s, unblockSelector: a, maskTextClass: o, maskTextSelector: c, unmaskTextSelector: u, skipChild: h = !1, inlineStylesheet: l = !0, maskInputSelector: d, unmaskInputSelector: f, maskAllText: p, maskInputOptions: m = {}, maskTextFn: _, maskInputFn: y, slimDOMOptions: g, dataURLOptions: b = {}, inlineImages: w = !1, recordCanvas: v = !1, onSerialize: k, onIframeLoad: S, iframeLoadTimeout: x = 5e3, keepIframeSrcFn: T = (() => !1) } = e; let { preserveWhiteSpace: E = !0 } = e; const I = Xn(t, { doc: n, blockClass: r, blockSelector: s, unblockSelector: a, maskTextClass: o, maskTextSelector: c, unmaskTextSelector: u, inlineStylesheet: l, maskInputSelector: d, unmaskInputSelector: f, maskAllText: p, maskInputOptions: m, maskTextFn: _, maskInputFn: y, dataURLOptions: b, inlineImages: w, recordCanvas: v, keepIframeSrcFn: T }); if (!I) return console.warn(t, "not serialized"), null; let A; A = "__sn" in t ? t.__sn.id : !function (t, e) { if (e.comment && t.type === Tn.Comment) return !0; if (t.type === Tn.Element) { if (e.script && ("script" === t.tagName || "link" === t.tagName && ("preload" === t.attributes.rel || "modulepreload" === t.attributes.rel) && "script" === t.attributes.as || "link" === t.tagName && "prefetch" === t.attributes.rel && "string" == typeof t.attributes.href && t.attributes.href.endsWith(".js"))) return !0; if (e.headFavicon && ("link" === t.tagName && "shortcut icon" === t.attributes.rel || "meta" === t.tagName && (Gn(t.attributes.name).match(/^msapplication-tile(image|color)$/) || "application-name" === Gn(t.attributes.name) || "icon" === Gn(t.attributes.rel) || "apple-touch-icon" === Gn(t.attributes.rel) || "shortcut icon" === Gn(t.attributes.rel)))) return !0; if ("meta" === t.tagName) { if (e.headMetaDescKeywords && Gn(t.attributes.name).match(/^description|keywords$/)) return !0; if (e.headMetaSocial && (Gn(t.attributes.property).match(/^(og|twitter|fb):/) || Gn(t.attributes.name).match(/^(og|twitter):/) || "pinterest" === Gn(t.attributes.name))) return !0; if (e.headMetaRobots && ("robots" === Gn(t.attributes.name) || "googlebot" === Gn(t.attributes.name) || "bingbot" === Gn(t.attributes.name))) return !0; if (e.headMetaHttpEquiv && void 0 !== t.attributes["http-equiv"]) return !0; if (e.headMetaAuthorship && ("author" === Gn(t.attributes.name) || "generator" === Gn(t.attributes.name) || "framework" === Gn(t.attributes.name) || "publisher" === Gn(t.attributes.name) || "progid" === Gn(t.attributes.name) || Gn(t.attributes.property).match(/^article:/) || Gn(t.attributes.property).match(/^product:/))) return !0; if (e.headMetaVerification && ("google-site-verification" === Gn(t.attributes.name) || "yandex-verification" === Gn(t.attributes.name) || "csrf-token" === Gn(t.attributes.name) || "p:domain_verify" === Gn(t.attributes.name) || "verify-v1" === Gn(t.attributes.name) || "verification" === Gn(t.attributes.name) || "shopify-checkout-api-token" === Gn(t.attributes.name))) return !0 } } return !1 }(I, g) && (E || I.type !== Tn.Text || I.isStyle || I.textContent.replace(/^\s+|\s+$/gm, "").length) ? On++ : -2; const C = Object.assign(I, { id: A }); if (t.__sn = C, -2 === A) return null; i[A] = t, k && k(t); let O = !h; if (C.type === Tn.Element && (O = O && !C.needBlock, delete C.needBlock, t.shadowRoot && (C.isShadowHost = !0)), (C.type === Tn.Document || C.type === Tn.Element) && O) { g.headWhitespace && I.type === Tn.Element && "head" === I.tagName && (E = !1); const e = { doc: n, map: i, blockClass: r, blockSelector: s, unblockSelector: a, maskTextClass: o, maskTextSelector: c, unmaskTextSelector: u, skipChild: h, inlineStylesheet: l, maskInputSelector: d, unmaskInputSelector: f, maskAllText: p, maskInputOptions: m, maskTextFn: _, maskInputFn: y, slimDOMOptions: g, dataURLOptions: b, inlineImages: w, recordCanvas: v, preserveWhiteSpace: E, onSerialize: k, onIframeLoad: S, iframeLoadTimeout: x, keepIframeSrcFn: T }; for (const n of Array.from(t.childNodes)) { const t = Jn(n, e); t && C.childNodes.push(t) } if (function (t) { return t.nodeType === t.ELEMENT_NODE }(t) && t.shadowRoot) for (const n of Array.from(t.shadowRoot.childNodes)) { const t = Jn(n, e); t && (t.isShadow = !0, C.childNodes.push(t)) } } return t.parentNode && En(t.parentNode) && (C.isShadow = !0), C.type === Tn.Element && "iframe" === C.tagName && function (t, e, n) { const i = t.contentWindow; if (!i) return; let r, s = !1; try { r = i.document.readyState } catch (t) { return } if ("complete" !== r) { const i = setTimeout((() => { s || (e(), s = !0) }), n); return void t.addEventListener("load", (() => { clearTimeout(i), s = !0, e() })) } const a = "about:blank"; i.location.href === a && t.src !== a && "" !== t.src ? t.addEventListener("load", e) : setTimeout(e, 0) }(t, (() => { const e = t.contentDocument; if (e && S) { const n = Jn(e, { doc: e, map: i, blockClass: r, blockSelector: s, unblockSelector: a, maskTextClass: o, maskTextSelector: c, unmaskTextSelector: u, skipChild: !1, inlineStylesheet: l, maskInputSelector: d, unmaskInputSelector: f, maskAllText: p, maskInputOptions: m, maskTextFn: _, maskInputFn: y, slimDOMOptions: g, dataURLOptions: b, inlineImages: w, recordCanvas: v, preserveWhiteSpace: E, onSerialize: k, onIframeLoad: S, iframeLoadTimeout: x, keepIframeSrcFn: T }); n && S(t, n) } }), x), C } function Kn(t, e, n) { return ("video" === t || "audio" === t) && "autoplay" === e } var Yn, Vn, Qn, ti, ei, ni; function ii(t, e, n = document) { const i = { capture: !0, passive: !0 }; return n.addEventListener(t, e, i), () => n.removeEventListener(t, e, i) } !function (t) { t[t.DomContentLoaded = 0] = "DomContentLoaded", t[t.Load = 1] = "Load", t[t.FullSnapshot = 2] = "FullSnapshot", t[t.IncrementalSnapshot = 3] = "IncrementalSnapshot", t[t.Meta = 4] = "Meta", t[t.Custom = 5] = "Custom", t[t.Plugin = 6] = "Plugin" }(Yn || (Yn = {})), function (t) { t[t.Mutation = 0] = "Mutation", t[t.MouseMove = 1] = "MouseMove", t[t.MouseInteraction = 2] = "MouseInteraction", t[t.Scroll = 3] = "Scroll", t[t.ViewportResize = 4] = "ViewportResize", t[t.Input = 5] = "Input", t[t.TouchMove = 6] = "TouchMove", t[t.MediaInteraction = 7] = "MediaInteraction", t[t.StyleSheetRule = 8] = "StyleSheetRule", t[t.CanvasMutation = 9] = "CanvasMutation", t[t.Font = 10] = "Font", t[t.Log = 11] = "Log", t[t.Drag = 12] = "Drag", t[t.StyleDeclaration = 13] = "StyleDeclaration" }(Vn || (Vn = {})), function (t) { t[t.MouseUp = 0] = "MouseUp", t[t.MouseDown = 1] = "MouseDown", t[t.Click = 2] = "Click", t[t.ContextMenu = 3] = "ContextMenu", t[t.DblClick = 4] = "DblClick", t[t.Focus = 5] = "Focus", t[t.Blur = 6] = "Blur", t[t.TouchStart = 7] = "TouchStart", t[t.TouchMove_Departed = 8] = "TouchMove_Departed", t[t.TouchEnd = 9] = "TouchEnd", t[t.TouchCancel = 10] = "TouchCancel" }(Qn || (Qn = {})), function (t) { t[t["2D"] = 0] = "2D", t[t.WebGL = 1] = "WebGL", t[t.WebGL2 = 2] = "WebGL2" }(ti || (ti = {})), function (t) { t[t.Play = 0] = "Play", t[t.Pause = 1] = "Pause", t[t.Seeked = 2] = "Seeked", t[t.VolumeChange = 3] = "VolumeChange" }(ei || (ei = {})), function (t) { t.Start = "start", t.Pause = "pause", t.Resume = "resume", t.Resize = "resize", t.Finish = "finish", t.FullsnapshotRebuilded = "fullsnapshot-rebuilded", t.LoadStylesheetStart = "load-stylesheet-start", t.LoadStylesheetEnd = "load-stylesheet-end", t.SkipStart = "skip-start", t.SkipEnd = "skip-end", t.MouseInteraction = "mouse-interaction", t.EventCast = "event-cast", t.CustomEvent = "custom-event", t.Flush = "flush", t.StateChange = "state-change", t.PlayBack = "play-back" }(ni || (ni = {})); const ri = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording."; let si = { map: {}, getId: () => (console.error(ri), -1), getNode: () => (console.error(ri), null), removeNodeFromMap() { console.error(ri) }, has: () => (console.error(ri), !1), reset() { console.error(ri) } }; function ai(t, e, n = {}) { let i = null, r = 0; return function (s) { let a = Date.now(); r || !1 !== n.leading || (r = a); let o = e - (a - r), c = this, u = arguments; o <= 0 || o > e ? (i && (clearTimeout(i), i = null), r = a, t.apply(c, u)) : i || !1 === n.trailing || (i = setTimeout((() => { r = !1 === n.leading ? 0 : Date.now(), i = null, t.apply(c, u) }), o)) } } function oi(t, e, n, i, r = window) { const s = r.Object.getOwnPropertyDescriptor(t, e); return r.Object.defineProperty(t, e, i ? n : { set(t) { setTimeout((() => { n.set.call(this, t) }), 0), s && s.set && s.set.call(this, t) } }), () => oi(t, e, s || {}, !0) } function ci(t, e, n) { try { if (!(e in t)) return () => { }; const i = t[e], r = n(i); return "function" == typeof r && (r.prototype = r.prototype || {}, Object.defineProperties(r, { __rrweb_original__: { enumerable: !1, value: i } })), t[e] = r, () => { t[e] = i } } catch (t) { return () => { } } } function ui() { return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight } function hi() { return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth } function li(t, e, n, i) { if (!t) return !1; if (t.nodeType === t.ELEMENT_NODE) { let r = !1; const s = i && t.matches(i); return "string" == typeof e ? r = void 0 !== t.closest ? !s && null !== t.closest("." + e) : !s && t.classList.contains(e) : !s && t.classList.forEach((t => { e.test(t) && (r = !0) })), !r && n && (r = t.matches(n)), !s && r || li(t.parentNode, e, n, i) } return t.nodeType, t.TEXT_NODE, li(t.parentNode, e, n, i) } function di(t) { return "__sn" in t && -2 === t.__sn.id } function fi(t, e) { if (En(t)) return !1; const n = e.getId(t); return !e.has(n) || (!t.parentNode || t.parentNode.nodeType !== t.DOCUMENT_NODE) && (!t.parentNode || fi(t.parentNode, e)) } function pi(t) { return Boolean(t.changedTouches) } function mi(t) { return "__sn" in t && (t.__sn.type === Tn.Element && "iframe" === t.__sn.tagName) } function _i(t) { return Boolean(null == t ? void 0 : t.shadowRoot) } function yi(t) { return "__ln" in t } "undefined" != typeof window && window.Proxy && window.Reflect && (si = new Proxy(si, { get: (t, e, n) => ("map" === e && console.error(ri), Reflect.get(t, e, n)) })); class gi { constructor() { this.length = 0, this.head = null } get(t) { if (t >= this.length) throw new Error("Position outside of list range"); let e = this.head; for (let n = 0; n < t; n++)e = (null == e ? void 0 : e.next) || null; return e } addNode(t) { const e = { value: t, previous: null, next: null }; if (t.__ln = e, t.previousSibling && yi(t.previousSibling)) { const n = t.previousSibling.__ln.next; e.next = n, e.previous = t.previousSibling.__ln, t.previousSibling.__ln.next = e, n && (n.previous = e) } else if (t.nextSibling && yi(t.nextSibling) && t.nextSibling.__ln.previous) { const n = t.nextSibling.__ln.previous; e.previous = n, e.next = t.nextSibling.__ln, t.nextSibling.__ln.previous = e, n && (n.next = e) } else this.head && (this.head.previous = e), e.next = this.head, this.head = e; this.length++ } removeNode(t) { const e = t.__ln; this.head && (e.previous ? (e.previous.next = e.next, e.next && (e.next.previous = e.previous)) : (this.head = e.next, this.head && (this.head.previous = null)), t.__ln && delete t.__ln, this.length--) } } const bi = (t, e) => `${t}@${e}`; function wi(t) { return "__sn" in t } class vi { constructor() { this.frozen = !1, this.locked = !1, this.texts = [], this.attributes = [], this.removes = [], this.mapRemoves = [], this.movedMap = {}, this.addedSet = new Set, this.movedSet = new Set, this.droppedSet = new Set, this.processMutations = t => { t.forEach(this.processMutation), this.emit() }, this.emit = () => { if (this.frozen || this.locked) return; const t = [], e = new gi, n = t => { let e = t, n = -2; for (; -2 === n;)e = e && e.nextSibling, n = e && this.mirror.getId(e); return n }, i = i => { var r, s, a, o, c; const u = i.getRootNode ? null === (r = i.getRootNode()) || void 0 === r ? void 0 : r.host : null; let h = u; for (; null === (a = null === (s = null == h ? void 0 : h.getRootNode) || void 0 === s ? void 0 : s.call(h)) || void 0 === a ? void 0 : a.host;)h = (null === (c = null === (o = null == h ? void 0 : h.getRootNode) || void 0 === o ? void 0 : o.call(h)) || void 0 === c ? void 0 : c.host) || null; const l = !(this.doc.contains(i) || h && this.doc.contains(h)); if (!i.parentNode || l) return; const d = En(i.parentNode) ? this.mirror.getId(u) : this.mirror.getId(i.parentNode), f = n(i); if (-1 === d || -1 === f) return e.addNode(i); let p = Jn(i, { doc: this.doc, map: this.mirror.map, blockClass: this.blockClass, blockSelector: this.blockSelector, unblockSelector: this.unblockSelector, maskTextClass: this.maskTextClass, maskTextSelector: this.maskTextSelector, unmaskTextSelector: this.unmaskTextSelector, maskInputSelector: this.maskInputSelector, unmaskInputSelector: this.unmaskInputSelector, skipChild: !0, inlineStylesheet: this.inlineStylesheet, maskAllText: this.maskAllText, maskInputOptions: this.maskInputOptions, maskTextFn: this.maskTextFn, maskInputFn: this.maskInputFn, slimDOMOptions: this.slimDOMOptions, recordCanvas: this.recordCanvas, inlineImages: this.inlineImages, onSerialize: t => { mi(t) && this.iframeManager.addIframe(t), _i(i) && this.shadowDomManager.addShadowRoot(i.shadowRoot, document) }, onIframeLoad: (t, e) => { this.iframeManager.attachIframe(t, e), this.shadowDomManager.observeAttachShadow(t) } }); p && t.push({ parentId: d, nextId: f, node: p }) }; for (; this.mapRemoves.length;)this.mirror.removeNodeFromMap(this.mapRemoves.shift()); for (const t of this.movedSet) Si(this.removes, t, this.mirror) && !this.movedSet.has(t.parentNode) || i(t); for (const t of this.addedSet) xi(this.droppedSet, t) || Si(this.removes, t, this.mirror) ? xi(this.movedSet, t) ? i(t) : this.droppedSet.add(t) : i(t); let r = null; for (; e.length;) { let t = null; if (r) { const e = this.mirror.getId(r.value.parentNode), i = n(r.value); -1 !== e && -1 !== i && (t = r) } if (!t) for (let i = e.length - 1; i >= 0; i--) { const r = e.get(i); if (r) { const e = this.mirror.getId(r.value.parentNode), i = n(r.value); if (-1 !== e && -1 !== i) { t = r; break } } } if (!t) { for (; e.head;)e.removeNode(e.head.value); break } r = t.previous, e.removeNode(t.value), i(t.value) } const s = { texts: this.texts.map((t => ({ id: this.mirror.getId(t.node), value: t.value }))).filter((t => this.mirror.has(t.id))), attributes: this.attributes.map((t => ({ id: this.mirror.getId(t.node), attributes: t.attributes }))).filter((t => this.mirror.has(t.id))), removes: this.removes, adds: t }; (s.texts.length || s.attributes.length || s.removes.length || s.adds.length) && (this.texts = [], this.attributes = [], this.removes = [], this.addedSet = new Set, this.movedSet = new Set, this.droppedSet = new Set, this.movedMap = {}, this.mutationCb(s)) }, this.processMutation = t => { if (!di(t.target)) switch (t.type) { case "characterData": { const e = t.target.textContent; li(t.target, this.blockClass, this.blockSelector, this.unblockSelector) || e === t.oldValue || this.texts.push({ value: Wn(t.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextSelector, this.maskAllText) && e ? this.maskTextFn ? this.maskTextFn(e) : e.replace(/[\S]/g, "*") : e, node: t.target }); break } case "attributes": { const e = t.target; let n = e.getAttribute(t.attributeName); if ("value" === t.attributeName && (n = An({ input: e, maskInputSelector: this.maskInputSelector, unmaskInputSelector: this.unmaskInputSelector, maskInputOptions: this.maskInputOptions, tagName: e.tagName, type: e.getAttribute("type"), value: n, maskInputFn: this.maskInputFn })), li(t.target, this.blockClass, this.blockSelector, this.unblockSelector) || n === t.oldValue) return; let i = this.attributes.find((e => e.node === t.target)); if (i || (i = { node: t.target, attributes: {} }, this.attributes.push(i)), "type" === t.attributeName && "INPUT" === t.target.tagName && "password" === (t.oldValue || "").toLowerCase() && t.target.setAttribute("rr_is_password", "true"), "style" === t.attributeName) { const n = this.doc.createElement("span"); t.oldValue && n.setAttribute("style", t.oldValue), void 0 !== i.attributes.style && null !== i.attributes.style || (i.attributes.style = {}); try { const t = i.attributes.style; for (const i of Array.from(e.style)) { const r = e.style.getPropertyValue(i), s = e.style.getPropertyPriority(i); r === n.style.getPropertyValue(i) && s === n.style.getPropertyPriority(i) || (t[i] = "" === s ? r : [r, s]) } for (const i of Array.from(n.style)) "" === e.style.getPropertyValue(i) && (t[i] = !1) } catch (t) { console.warn("[rrweb] Error when parsing update to style attribute:", t) } } else { const e = t.target; i.attributes[t.attributeName] = qn(this.doc, e, e.tagName, t.attributeName, n, this.maskAllText, this.unmaskTextSelector, this.maskTextFn) } break } case "childList": t.addedNodes.forEach((e => this.genAdds(e, t.target))), t.removedNodes.forEach((e => { const n = this.mirror.getId(e), i = En(t.target) ? this.mirror.getId(t.target.host) : this.mirror.getId(t.target); li(t.target, this.blockClass, this.blockSelector, this.unblockSelector) || di(e) || (this.addedSet.has(e) ? (ki(this.addedSet, e), this.droppedSet.add(e)) : this.addedSet.has(t.target) && -1 === n || fi(t.target, this.mirror) || (this.movedSet.has(e) && this.movedMap[bi(n, i)] ? ki(this.movedSet, e) : this.removes.push({ parentId: i, id: n, isShadow: !!En(t.target) || void 0 })), this.mapRemoves.push(e)) })) } }, this.genAdds = (t, e) => { if (!e || !li(e, this.blockClass, this.blockSelector, this.unblockSelector)) { if (wi(t)) { if (di(t)) return; this.movedSet.add(t); let n = null; e && wi(e) && (n = e.__sn.id), n && (this.movedMap[bi(t.__sn.id, n)] = !0) } else this.addedSet.add(t), this.droppedSet.delete(t); li(t, this.blockClass, this.blockSelector, this.unblockSelector) || t.childNodes.forEach((t => this.genAdds(t))) } } } init(t) { ["mutationCb", "blockClass", "blockSelector", "unblockSelector", "maskTextClass", "maskTextSelector", "unmaskTextSelector", "maskInputSelector", "unmaskInputSelector", "inlineStylesheet", "maskAllText", "maskInputOptions", "maskTextFn", "maskInputFn", "recordCanvas", "inlineImages", "slimDOMOptions", "doc", "mirror", "iframeManager", "shadowDomManager", "canvasManager"].forEach((e => { this[e] = t[e] })) } freeze() { this.frozen = !0, this.canvasManager.freeze() } unfreeze() { this.frozen = !1, this.canvasManager.unfreeze(), this.emit() } isFrozen() { return this.frozen } lock() { this.locked = !0, this.canvasManager.lock() } unlock() { this.locked = !1, this.canvasManager.unlock(), this.emit() } reset() { this.shadowDomManager.reset(), this.canvasManager.reset() } } function ki(t, e) { t.delete(e), e.childNodes.forEach((e => ki(t, e))) } function Si(t, e, n) { const { parentNode: i } = e; if (!i) return !1; const r = n.getId(i); return !!t.some((t => t.id === r)) || Si(t, i, n) } function xi(t, e) { const { parentNode: n } = e; return !!n && (!!t.has(n) || xi(t, n)) } const Ti = t => (...e) => { try { return t(...e) } catch (t) { try { t.__rrweb__ = !0 } catch (t) { } throw t } }, Ei = []; function Ii(t) { try { if ("composedPath" in t) { const e = t.composedPath(); if (e.length) return e[0] } else if ("path" in t && t.path.length) return t.path[0] } catch (t) { } return t && t.target } function Ai(t, e) { var n, i; const r = new vi; Ei.push(r), r.init(t); let s = window.MutationObserver || window.__rrMutationObserver; const a = null === (i = null === (n = null === window || void 0 === window ? void 0 : window.Zone) || void 0 === n ? void 0 : n.__symbol__) || void 0 === i ? void 0 : i.call(n, "MutationObserver"); a && window[a] && (s = window[a]); const o = new s(Ti((e => { t.onMutation && !1 === t.onMutation(e) || r.processMutations(e) }))); return o.observe(e, { attributes: !0, attributeOldValue: !0, characterData: !0, characterDataOldValue: !0, childList: !0, subtree: !0 }), o } function Ci({ mouseInteractionCb: t, doc: e, mirror: n, blockClass: i, blockSelector: r, unblockSelector: s, sampling: a }) { if (!1 === a.mouseInteraction) return () => { }; const o = !0 === a.mouseInteraction || void 0 === a.mouseInteraction ? {} : a.mouseInteraction, c = []; return Object.keys(Qn).filter((t => Number.isNaN(Number(t)) && !t.endsWith("_Departed") && !1 !== o[t])).forEach((a => { const o = a.toLowerCase(), u = Ti((e => a => { const o = Ii(a); if (li(o, i, r, s)) return; const c = pi(a) ? a.changedTouches[0] : a; if (!c) return; const u = n.getId(o), { clientX: h, clientY: l } = c; Ti(t)({ type: Qn[e], id: u, x: h, y: l }) })(a)); c.push(ii(o, u, e)) })), Ti((() => { c.forEach((t => t())) })) } function Oi({ scrollCb: t, doc: e, mirror: n, blockClass: i, blockSelector: r, unblockSelector: s, sampling: a }) { const o = ai((a => { const o = Ii(a); if (!o || li(o, i, r, s)) return; const c = n.getId(o); if (o === e) { const n = e.scrollingElement || e.documentElement; Ti(t)({ id: c, x: n.scrollLeft, y: n.scrollTop }) } else Ti(t)({ id: c, x: o.scrollLeft, y: o.scrollTop }) }), a.scroll || 100); return ii("scroll", Ti(o), e) } function Ri(t, e) { const n = Object.assign({}, t); return e || delete n.userTriggered, n } const zi = ["INPUT", "TEXTAREA", "SELECT"], Di = new WeakMap; function Li({ inputCb: t, doc: e, mirror: n, blockClass: i, blockSelector: r, unblockSelector: s, ignoreClass: a, ignoreSelector: o, maskInputSelector: c, unmaskInputSelector: u, maskInputOptions: h, maskInputFn: l, sampling: d, userTriggeredOnInput: f }) { function p(t) { let n = Ii(t); const d = n && n.tagName, p = t.isTrusted; if ("OPTION" === d && (n = n.parentElement), !n || !d || zi.indexOf(d) < 0 || li(n, i, r, s)) return; let _ = n.type; if (n.classList.contains(a) || o && n.matches(o)) return; let y = n.value, g = !1; n.hasAttribute("rr_is_password") && (_ = "password"), "radio" === _ || "checkbox" === _ ? g = n.checked : function ({ tagName: t, type: e, maskInputOptions: n, maskInputSelector: i }) { return i || In({ maskInputOptions: n, tagName: t, type: e }) }({ maskInputOptions: h, maskInputSelector: c, tagName: d, type: _ }) && (y = An({ input: n, maskInputOptions: h, maskInputSelector: c, unmaskInputSelector: u, tagName: d, type: _, value: y, maskInputFn: l })), m(n, Ti(Ri)({ text: y, isChecked: g, userTriggered: p }, f)); const b = n.name; "radio" === _ && b && g && e.querySelectorAll(`input[type="radio"][name="${b}"]`).forEach((t => { t !== n && m(t, Ti(Ri)({ text: t.value, isChecked: !g, userTriggered: !1 }, f)) })) } function m(e, i) { const r = Di.get(e); if (!r || r.text !== i.text || r.isChecked !== i.isChecked) { Di.set(e, i); const r = n.getId(e); t(Object.assign(Object.assign({}, i), { id: r })) } } const _ = ("last" === d.input ? ["change"] : ["input", "change"]).map((t => ii(t, Ti(p), e))), y = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, "value"), g = [[HTMLInputElement.prototype, "value"], [HTMLInputElement.prototype, "checked"], [HTMLSelectElement.prototype, "value"], [HTMLTextAreaElement.prototype, "value"], [HTMLSelectElement.prototype, "selectedIndex"], [HTMLOptionElement.prototype, "selected"]]; return y && y.set && _.push(...g.map((t => oi(t[0], t[1], { set() { Ti(p)({ target: this }) } })))), Ti((() => { _.forEach((t => t())) })) } function Mi(t) { return function (t, e) { if (Ni("CSSGroupingRule") && t.parentRule instanceof CSSGroupingRule || Ni("CSSMediaRule") && t.parentRule instanceof CSSMediaRule || Ni("CSSSupportsRule") && t.parentRule instanceof CSSSupportsRule || Ni("CSSConditionRule") && t.parentRule instanceof CSSConditionRule) { const n = Array.from(t.parentRule.cssRules).indexOf(t); e.unshift(n) } else { const n = Array.from(t.parentStyleSheet.cssRules).indexOf(t); e.unshift(n) } return e }(t, []) } function $i(t, e = {}) { const n = t.doc.defaultView; if (!n) return () => { }; !function (t, e) { const { mutationCb: n, mousemoveCb: i, mouseInteractionCb: r, scrollCb: s, viewportResizeCb: a, inputCb: o, mediaInteractionCb: c, styleSheetRuleCb: u, styleDeclarationCb: h, canvasMutationCb: l, fontCb: d } = t; t.mutationCb = (...t) => { e.mutation && e.mutation(...t), n(...t) }, t.mousemoveCb = (...t) => { e.mousemove && e.mousemove(...t), i(...t) }, t.mouseInteractionCb = (...t) => { e.mouseInteraction && e.mouseInteraction(...t), r(...t) }, t.scrollCb = (...t) => { e.scroll && e.scroll(...t), s(...t) }, t.viewportResizeCb = (...t) => { e.viewportResize && e.viewportResize(...t), a(...t) }, t.inputCb = (...t) => { e.input && e.input(...t), o(...t) }, t.mediaInteractionCb = (...t) => { e.mediaInteaction && e.mediaInteaction(...t), c(...t) }, t.styleSheetRuleCb = (...t) => { e.styleSheetRule && e.styleSheetRule(...t), u(...t) }, t.styleDeclarationCb = (...t) => { e.styleDeclaration && e.styleDeclaration(...t), h(...t) }, t.canvasMutationCb = (...t) => { e.canvasMutation && e.canvasMutation(...t), l(...t) }, t.fontCb = (...t) => { e.font && e.font(...t), d(...t) } }(t, e); const i = Ai(t, t.doc), r = function ({ mousemoveCb: t, sampling: e, doc: n, mirror: i }) { if (!1 === e.mousemove) return () => { }; const r = "number" == typeof e.mousemove ? e.mousemove : 50, s = "number" == typeof e.mousemoveCallback ? e.mousemoveCallback : 500; let a, o = []; const c = ai((e => { const n = Date.now() - a; Ti(t)(o.map((t => (t.timeOffset -= n, t))), e), o = [], a = null }), s), u = ai((t => { const e = Ii(t), { clientX: n, clientY: r } = pi(t) ? t.changedTouches[0] : t; a || (a = Date.now()), o.push({ x: n, y: r, id: i.getId(e), timeOffset: Date.now() - a }), c("undefined" != typeof DragEvent && t instanceof DragEvent ? Vn.Drag : t instanceof MouseEvent ? Vn.MouseMove : Vn.TouchMove) }), r, { trailing: !1 }), h = [ii("mousemove", Ti(u), n), ii("touchmove", Ti(u), n), ii("drag", Ti(u), n)]; return Ti((() => { h.forEach((t => t())) })) }(t), s = Ci(t), a = Oi(t), o = function ({ viewportResizeCb: t }) { let e = -1, n = -1; const i = ai((() => { const i = ui(), r = hi(); e === i && n === r || (Ti(t)({ width: Number(r), height: Number(i) }), e = i, n = r) }), 200); return ii("resize", Ti(i), window) }(t), c = Li(t), u = function ({ mediaInteractionCb: t, blockClass: e, blockSelector: n, unblockSelector: i, mirror: r, sampling: s }) { const a = a => ai(Ti((s => { const o = Ii(s); if (!o || li(o, e, n, i)) return; const { currentTime: c, volume: u, muted: h } = o; t({ type: a, id: r.getId(o), currentTime: c, volume: u, muted: h }) })), s.media || 500), o = [ii("play", a(0)), ii("pause", a(1)), ii("seeked", a(2)), ii("volumechange", a(3))]; return Ti((() => { o.forEach((t => t())) })) }(t), h = function ({ styleSheetRuleCb: t, mirror: e }, { win: n }) { if (!n.CSSStyleSheet || !n.CSSStyleSheet.prototype) return () => { }; const i = n.CSSStyleSheet.prototype.insertRule; n.CSSStyleSheet.prototype.insertRule = new Proxy(i, { apply: Ti(((n, i, r) => { const [s, a] = r, o = e.getId(i.ownerNode); return -1 !== o && t({ id: o, adds: [{ rule: s, index: a }] }), n.apply(i, r) })) }); const r = n.CSSStyleSheet.prototype.deleteRule; n.CSSStyleSheet.prototype.deleteRule = new Proxy(r, { apply: Ti(((n, i, r) => { const [s] = r, a = e.getId(i.ownerNode); return -1 !== a && t({ id: a, removes: [{ index: s }] }), n.apply(i, r) })) }); const s = {}; Fi("CSSGroupingRule") ? s.CSSGroupingRule = n.CSSGroupingRule : (Fi("CSSMediaRule") && (s.CSSMediaRule = n.CSSMediaRule), Fi("CSSConditionRule") && (s.CSSConditionRule = n.CSSConditionRule), Fi("CSSSupportsRule") && (s.CSSSupportsRule = n.CSSSupportsRule)); const a = {}; return Object.entries(s).forEach((([n, i]) => { a[n] = { insertRule: i.prototype.insertRule, deleteRule: i.prototype.deleteRule }, i.prototype.insertRule = new Proxy(a[n].insertRule, { apply: Ti(((n, i, r) => { const [s, a] = r, o = e.getId(i.parentStyleSheet.ownerNode); return -1 !== o && t({ id: o, adds: [{ rule: s, index: [...Mi(i), a || 0] }] }), n.apply(i, r) })) }), i.prototype.deleteRule = new Proxy(a[n].deleteRule, { apply: Ti(((n, i, r) => { const [s] = r, a = e.getId(i.parentStyleSheet.ownerNode); return -1 !== a && t({ id: a, removes: [{ index: [...Mi(i), s] }] }), n.apply(i, r) })) }) })), Ti((() => { n.CSSStyleSheet.prototype.insertRule = i, n.CSSStyleSheet.prototype.deleteRule = r, Object.entries(s).forEach((([t, e]) => { e.prototype.insertRule = a[t].insertRule, e.prototype.deleteRule = a[t].deleteRule })) })) }(t, { win: n }), l = function ({ styleDeclarationCb: t, mirror: e }, { win: n }) { const i = n.CSSStyleDeclaration.prototype.setProperty; n.CSSStyleDeclaration.prototype.setProperty = new Proxy(i, { apply: Ti(((n, i, r) => { var s, a; const [o, c, u] = r, h = e.getId(null === (a = null === (s = i.parentRule) || void 0 === s ? void 0 : s.parentStyleSheet) || void 0 === a ? void 0 : a.ownerNode); return -1 !== h && t({ id: h, set: { property: o, value: c, priority: u }, index: Mi(i.parentRule) }), n.apply(i, r) })) }); const r = n.CSSStyleDeclaration.prototype.removeProperty; return n.CSSStyleDeclaration.prototype.removeProperty = new Proxy(r, { apply: Ti(((n, i, r) => { var s, a; const [o] = r, c = e.getId(null === (a = null === (s = i.parentRule) || void 0 === s ? void 0 : s.parentStyleSheet) || void 0 === a ? void 0 : a.ownerNode); return -1 !== c && t({ id: c, remove: { property: o }, index: Mi(i.parentRule) }), n.apply(i, r) })) }), Ti((() => { n.CSSStyleDeclaration.prototype.setProperty = i, n.CSSStyleDeclaration.prototype.removeProperty = r })) }(t, { win: n }), d = t.collectFonts ? function ({ fontCb: t, doc: e }) { const n = e.defaultView; if (!n) return () => { }; const i = [], r = new WeakMap, s = n.FontFace; n.FontFace = function (t, e, n) { const i = new s(t, e, n); return r.set(i, { family: t, buffer: "string" != typeof e, descriptors: n, fontSource: "string" == typeof e ? e : JSON.stringify(Array.from(new Uint8Array(e))) }), i }; const a = ci(e.fonts, "add", (function (e) { return function (n) { return setTimeout((() => { const e = r.get(n); e && (t(e), r.delete(n)) }), 0), e.apply(this, [n]) } })); return i.push((() => { n.FontFace = s })), i.push(a), Ti((() => { i.forEach((t => t())) })) }(t) : () => { }, f = []; for (const e of t.plugins) f.push(e.observer(e.callback, n, e.options)); return Ti((() => { Ei.forEach((t => t.reset())), i.disconnect(), r(), s(), a(), o(), c(), u(); try { h(), l() } catch (t) { } d(), f.forEach((t => t())) })) } function Ni(t) { return void 0 !== window[t] } function Fi(t) { return Boolean(void 0 !== window[t] && window[t].prototype && "insertRule" in window[t].prototype && "deleteRule" in window[t].prototype) } class ji { constructor(t) { this.iframes = new WeakMap, this.mutationCb = t.mutationCb } addIframe(t) { this.iframes.set(t, !0) } addLoadListener(t) { this.loadListener = t } attachIframe(t, e) { var n; this.mutationCb({ adds: [{ parentId: t.__sn.id, nextId: null, node: e }], removes: [], texts: [], attributes: [], isAttachIframe: !0 }), null === (n = this.loadListener) || void 0 === n || n.call(this, t) } } class Ui { constructor(t) { this.restorePatches = [], this.mutationCb = t.mutationCb, this.scrollCb = t.scrollCb, this.bypassOptions = t.bypassOptions, this.mirror = t.mirror; const e = this; this.restorePatches.push(ci(HTMLElement.prototype, "attachShadow", (function (t) { return function () { const n = t.apply(this, arguments); return this.shadowRoot && e.addShadowRoot(this.shadowRoot, this.ownerDocument), n } }))) } addShadowRoot(t, e) { Ai(Object.assign(Object.assign({}, this.bypassOptions), { doc: e, mutationCb: this.mutationCb, mirror: this.mirror, shadowDomManager: this }), t), Oi(Object.assign(Object.assign({}, this.bypassOptions), { scrollCb: this.scrollCb, doc: t, mirror: this.mirror })) } observeAttachShadow(t) { if (t.contentWindow) { const e = this; this.restorePatches.push(ci(t.contentWindow.HTMLElement.prototype, "attachShadow", (function (n) { return function () { const i = n.apply(this, arguments); return this.shadowRoot && e.addShadowRoot(this.shadowRoot, t.contentDocument), i } }))) } } reset() { this.restorePatches.forEach((t => t())) } } for (var Bi = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Hi = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256), Zi = 0; Zi < Bi.length; Zi++)Hi[Bi.charCodeAt(Zi)] = Zi; const Pi = new Map; const qi = (t, e, n) => { if (!t || !Gi(t, e) && "object" != typeof t) return; const i = function (t, e) { let n = Pi.get(t); return n || (n = new Map, Pi.set(t, n)), n.has(e) || n.set(e, []), n.get(e) }(n, t.constructor.name); let r = i.indexOf(t); return -1 === r && (r = i.length, i.push(t)), r }; function Wi(t, e, n) { if (t instanceof Array) return t.map((t => Wi(t, e, n))); if (null === t) return t; if (t instanceof Float32Array || t instanceof Float64Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Uint8Array || t instanceof Uint16Array || t instanceof Int16Array || t instanceof Int8Array || t instanceof Uint8ClampedArray) { return { rr_type: t.constructor.name, args: [Object.values(t)] } } if (t instanceof ArrayBuffer) { const e = t.constructor.name, n = function (t) { var e, n = new Uint8Array(t), i = n.length, r = ""; for (e = 0; e < i; e += 3)r += Bi[n[e] >> 2], r += Bi[(3 & n[e]) << 4 | n[e + 1] >> 4], r += Bi[(15 & n[e + 1]) << 2 | n[e + 2] >> 6], r += Bi[63 & n[e + 2]]; return i % 3 == 2 ? r = r.substring(0, r.length - 1) + "=" : i % 3 == 1 && (r = r.substring(0, r.length - 2) + "=="), r }(t); return { rr_type: e, base64: n } } if (t instanceof DataView) { return { rr_type: t.constructor.name, args: [Wi(t.buffer, e, n), t.byteOffset, t.byteLength] } } if (t instanceof HTMLImageElement) { const e = t.constructor.name, { src: n } = t; return { rr_type: e, src: n } } if (t instanceof ImageData) { return { rr_type: t.constructor.name, args: [Wi(t.data, e, n), t.width, t.height] } } if (Gi(t, e) || "object" == typeof t) { return { rr_type: t.constructor.name, index: qi(t, e, n) } } return t } const Xi = (t, e, n) => [...t].map((t => Wi(t, e, n))), Gi = (t, e) => { const n = ["WebGLActiveInfo", "WebGLBuffer", "WebGLFramebuffer", "WebGLProgram", "WebGLRenderbuffer", "WebGLShader", "WebGLShaderPrecisionFormat", "WebGLTexture", "WebGLUniformLocation", "WebGLVertexArrayObject", "WebGLVertexArrayObjectOES"].filter((t => "function" == typeof e[t])); return Boolean(n.find((n => t instanceof e[n]))) }; function Ji(t, e, n, i, r, s, a, o) { const c = [], u = Object.getOwnPropertyNames(t); for (const h of u) try { if ("function" != typeof t[h]) continue; const u = ci(t, h, (function (c) { return function (...u) { const l = c.apply(this, u); if (qi(l, o, t), !li(this.canvas, i, s, r)) { a.getId(this.canvas); const i = Xi([...u], o, t), r = { type: e, property: h, args: i }; n(this.canvas, r) } return l } })); c.push(u) } catch (i) { const r = oi(t, h, { set(t) { n(this.canvas, { type: e, property: h, args: [t], setter: !0 }) } }); c.push(r) } return c } class Ki { reset() { this.pendingCanvasMutations.clear(), this.resetObservers && this.resetObservers() } freeze() { this.frozen = !0 } unfreeze() { this.frozen = !1 } lock() { this.locked = !0 } unlock() { this.locked = !1 } constructor(t) { this.pendingCanvasMutations = new Map, this.rafStamps = { latestId: 0, invokeId: null }, this.frozen = !1, this.locked = !1, this.processMutation = function (t, e) { !(this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId) && this.rafStamps.invokeId || (this.rafStamps.invokeId = this.rafStamps.latestId), this.pendingCanvasMutations.has(t) || this.pendingCanvasMutations.set(t, []), this.pendingCanvasMutations.get(t).push(e) }, this.mutationCb = t.mutationCb, this.mirror = t.mirror, !0 === t.recordCanvas && this.initCanvasMutationObserver(t.win, t.blockClass, t.blockSelector, t.unblockSelector) } initCanvasMutationObserver(t, e, n, i) { this.startRAFTimestamping(), this.startPendingCanvasMutationFlusher(); const r = function (t, e, n, i) { const r = []; try { const s = ci(t.HTMLCanvasElement.prototype, "getContext", (function (t) { return function (r, ...s) { return li(this, e, n, i) || "__context" in this || (this.__context = r), t.apply(this, [r, ...s]) } })); r.push(s) } catch (t) { console.error("failed to patch HTMLCanvasElement.prototype.getContext") } return () => { r.forEach((t => t())) } }(t, e, i, n), s = function (t, e, n, i, r, s) { const a = [], o = Object.getOwnPropertyNames(e.CanvasRenderingContext2D.prototype); for (const s of o) try { if ("function" != typeof e.CanvasRenderingContext2D.prototype[s]) continue; const o = ci(e.CanvasRenderingContext2D.prototype, s, (function (e) { return function (...a) { return li(this.canvas, n, r, i) || setTimeout((() => { const e = [...a]; if ("drawImage" === s && e[0] && e[0] instanceof HTMLCanvasElement) { const t = e[0], n = t.getContext("2d"); let i = null == n ? void 0 : n.getImageData(0, 0, t.width, t.height), r = null == i ? void 0 : i.data; e[0] = JSON.stringify(r) } t(this.canvas, { type: ti["2D"], property: s, args: e }) }), 0), e.apply(this, a) } })); a.push(o) } catch (n) { const i = oi(e.CanvasRenderingContext2D.prototype, s, { set(e) { t(this.canvas, { type: ti["2D"], property: s, args: [e], setter: !0 }) } }); a.push(i) } return () => { a.forEach((t => t())) } }(this.processMutation.bind(this), t, e, i, n), a = function (t, e, n, i, r, s) { const a = []; return a.push(...Ji(e.WebGLRenderingContext.prototype, ti.WebGL, t, n, i, r, s, e)), void 0 !== e.WebGL2RenderingContext && a.push(...Ji(e.WebGL2RenderingContext.prototype, ti.WebGL2, t, n, i, r, s, e)), () => { a.forEach((t => t())) } }(this.processMutation.bind(this), t, e, i, n, this.mirror); this.resetObservers = () => { r(), s(), a() } } startPendingCanvasMutationFlusher() { requestAnimationFrame((() => this.flushPendingCanvasMutations())) } startRAFTimestamping() { const t = e => { this.rafStamps.latestId = e, requestAnimationFrame(t) }; requestAnimationFrame(t) } flushPendingCanvasMutations() { this.pendingCanvasMutations.forEach(((t, e) => { const n = this.mirror.getId(e); this.flushPendingCanvasMutationFor(e, n) })), requestAnimationFrame((() => this.flushPendingCanvasMutations())) } flushPendingCanvasMutationFor(t, e) { if (this.frozen || this.locked) return; const n = this.pendingCanvasMutations.get(t); if (!n || -1 === e) return; const i = n.map((t => { const e = function (t, e) { var n = {}; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (n[i] = t[i]); if (null != t && "function" == typeof Object.getOwnPropertySymbols) { var r = 0; for (i = Object.getOwnPropertySymbols(t); r < i.length; r++)e.indexOf(i[r]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[r]) && (n[i[r]] = t[i[r]]) } return n }(t, ["type"]); return e })), { type: r } = n[0]; this.mutationCb({ id: e, type: r, commands: i }), this.pendingCanvasMutations.delete(t) } } function Yi(t) { return Object.assign(Object.assign({}, t), { timestamp: Date.now() }) } let Vi, Qi; const tr = { map: {}, getId: t => t && t.__sn ? t.__sn.id : -1, getNode(t) { return this.map[t] || null }, removeNodeFromMap(t) { const e = t.__sn && t.__sn.id; delete this.map[e], t.childNodes && t.childNodes.forEach((t => this.removeNodeFromMap(t))) }, has(t) { return this.map.hasOwnProperty(t) }, reset() { this.map = {} } }; function er(t = {}) { const { emit: e, checkoutEveryNms: n, checkoutEveryNth: i, blockClass: r = "rr-block", blockSelector: s = null, unblockSelector: a = null, ignoreClass: o = "rr-ignore", ignoreSelector: c = null, maskTextClass: u = "rr-mask", maskTextSelector: h = null, maskInputSelector: l = null, unmaskTextSelector: d = null, unmaskInputSelector: f = null, inlineStylesheet: p = !0, maskAllText: m = !1, maskAllInputs: _, maskInputOptions: y, slimDOMOptions: g, maskInputFn: b, maskTextFn: w, hooks: v, packFn: k, sampling: S = {}, mousemoveWait: x, recordCanvas: T = !1, userTriggeredOnInput: E = !1, collectFonts: I = !1, inlineImages: A = !1, plugins: C, keepIframeSrcFn: O = (() => !1), onMutation: R } = t; if (!e) throw new Error("emit function is required"); void 0 !== x && void 0 === S.mousemove && (S.mousemove = x); const z = !0 === _ ? { color: !0, date: !0, "datetime-local": !0, email: !0, month: !0, number: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0, textarea: !0, select: !0, radio: !0, checkbox: !0 } : void 0 !== y ? y : {}, D = !0 === g || "all" === g ? { script: !0, comment: !0, headFavicon: !0, headWhitespace: !0, headMetaSocial: !0, headMetaRobots: !0, headMetaHttpEquiv: !0, headMetaVerification: !0, headMetaAuthorship: "all" === g, headMetaDescKeywords: "all" === g } : g || {}; let L; !function (t = window) { "NodeList" in t && !t.NodeList.prototype.forEach && (t.NodeList.prototype.forEach = Array.prototype.forEach), "DOMTokenList" in t && !t.DOMTokenList.prototype.forEach && (t.DOMTokenList.prototype.forEach = Array.prototype.forEach), Node.prototype.contains || (Node.prototype.contains = function (t) { if (!(0 in arguments)) throw new TypeError("1 argument is required"); do { if (this === t) return !0 } while (t = t && t.parentNode); return !1 }) }(); let M = 0; Vi = (t, r) => { var s; if (!(null === (s = Ei[0]) || void 0 === s ? void 0 : s.isFrozen()) || t.type === Yn.FullSnapshot || t.type === Yn.IncrementalSnapshot && t.data.source === Vn.Mutation || Ei.forEach((t => t.unfreeze())), e((t => { for (const e of C || []) e.eventProcessor && (t = e.eventProcessor(t)); return k && (t = k(t)), t })(t), r), t.type === Yn.FullSnapshot) L = t, M = 0; else if (t.type === Yn.IncrementalSnapshot) { if (t.data.source === Vn.Mutation && t.data.isAttachIframe) return; M++; const e = i && M >= i, r = n && t.timestamp - L.timestamp > n; (e || r) && Qi(!0) } }; const $ = t => { Vi(Yi({ type: Yn.IncrementalSnapshot, data: Object.assign({ source: Vn.Mutation }, t) })) }, N = t => Vi(Yi({ type: Yn.IncrementalSnapshot, data: Object.assign({ source: Vn.Scroll }, t) })), F = t => Vi(Yi({ type: Yn.IncrementalSnapshot, data: Object.assign({ source: Vn.CanvasMutation }, t) })), j = new ji({ mutationCb: $ }), U = new Ki({ recordCanvas: T, mutationCb: F, win: window, blockClass: r, blockSelector: s, unblockSelector: a, mirror: tr }), B = new Ui({ mutationCb: $, scrollCb: N, bypassOptions: { onMutation: R, blockClass: r, blockSelector: s, unblockSelector: a, maskTextClass: u, maskTextSelector: h, unmaskTextSelector: d, maskInputSelector: l, unmaskInputSelector: f, inlineStylesheet: p, maskAllText: m, maskInputOptions: z, maskTextFn: w, maskInputFn: b, recordCanvas: T, inlineImages: A, sampling: S, slimDOMOptions: D, iframeManager: j, canvasManager: U }, mirror: tr }); Qi = (t = !1) => { var e, n, i, o; Vi(Yi({ type: Yn.Meta, data: { href: window.location.href, width: hi(), height: ui() } }), t), Ei.forEach((t => t.lock())); const [c, _] = function (t, e) { const { blockClass: n = "rr-block", blockSelector: i = null, unblockSelector: r = null, maskTextClass: s = "rr-mask", maskTextSelector: a = null, unmaskTextSelector: o = null, inlineStylesheet: c = !0, inlineImages: u = !1, recordCanvas: h = !1, maskInputSelector: l = null, unmaskInputSelector: d = null, maskAllText: f = !1, maskAllInputs: p = !1, maskTextFn: m, maskInputFn: _, slimDOM: y = !1, dataURLOptions: g, preserveWhiteSpace: b, onSerialize: w, onIframeLoad: v, iframeLoadTimeout: k, keepIframeSrcFn: S = (() => !1) } = e || {}, x = {}; return [Jn(t, { doc: t, map: x, blockClass: n, blockSelector: i, unblockSelector: r, maskTextClass: s, maskTextSelector: a, unmaskTextSelector: o, skipChild: !1, inlineStylesheet: c, maskInputSelector: l, unmaskInputSelector: d, maskAllText: f, maskInputOptions: !0 === p ? { color: !0, date: !0, "datetime-local": !0, email: !0, month: !0, number: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0, textarea: !0, select: !0 } : !1 === p ? {} : p, maskTextFn: m, maskInputFn: _, slimDOMOptions: !0 === y || "all" === y ? { script: !0, comment: !0, headFavicon: !0, headWhitespace: !0, headMetaDescKeywords: "all" === y, headMetaSocial: !0, headMetaRobots: !0, headMetaHttpEquiv: !0, headMetaAuthorship: !0, headMetaVerification: !0 } : !1 === y ? {} : y, dataURLOptions: g, inlineImages: u, recordCanvas: h, preserveWhiteSpace: b, onSerialize: w, onIframeLoad: v, iframeLoadTimeout: k, keepIframeSrcFn: S }), x] }(document, { blockClass: r, blockSelector: s, unblockSelector: a, maskTextClass: u, maskTextSelector: h, unmaskTextSelector: d, maskInputSelector: l, unmaskInputSelector: f, inlineStylesheet: p, maskAllText: m, maskAllInputs: z, maskTextFn: w, slimDOM: D, recordCanvas: T, inlineImages: A, onSerialize: t => { mi(t) && j.addIframe(t), _i(t) && B.addShadowRoot(t.shadowRoot, document) }, onIframeLoad: (t, e) => { j.attachIframe(t, e), B.observeAttachShadow(t) }, keepIframeSrcFn: O }); if (!c) return console.warn("Failed to snapshot the document"); tr.map = _, Vi(Yi({ type: Yn.FullSnapshot, data: { node: c, initialOffset: { left: void 0 !== window.pageXOffset ? window.pageXOffset : (null === document || void 0 === document ? void 0 : document.documentElement.scrollLeft) || (null === (n = null === (e = null === document || void 0 === document ? void 0 : document.body) || void 0 === e ? void 0 : e.parentElement) || void 0 === n ? void 0 : n.scrollLeft) || (null === document || void 0 === document ? void 0 : document.body.scrollLeft) || 0, top: void 0 !== window.pageYOffset ? window.pageYOffset : (null === document || void 0 === document ? void 0 : document.documentElement.scrollTop) || (null === (o = null === (i = null === document || void 0 === document ? void 0 : document.body) || void 0 === i ? void 0 : i.parentElement) || void 0 === o ? void 0 : o.scrollTop) || (null === document || void 0 === document ? void 0 : document.body.scrollTop) || 0 } } })), Ei.forEach((t => t.unlock())) }; try { const t = []; t.push(ii("DOMContentLoaded", (() => { Vi(Yi({ type: Yn.DomContentLoaded, data: {} })) }))); const e = t => { var e; return Ti($i)({ onMutation: R, mutationCb: $, mousemoveCb: (t, e) => Vi(Yi({ type: Yn.IncrementalSnapshot, data: { source: e, positions: t } })), mouseInteractionCb: t => Vi(Yi({ type: Yn.IncrementalSnapshot, data: Object.assign({ source: Vn.MouseInteraction }, t) })), scrollCb: N, viewportResizeCb: t => Vi(Yi({ type: Yn.IncrementalSnapshot, data: Object.assign({ source: Vn.ViewportResize }, t) })), inputCb: t => Vi(Yi({ type: Yn.IncrementalSnapshot, data: Object.assign({ source: Vn.Input }, t) })), mediaInteractionCb: t => Vi(Yi({ type: Yn.IncrementalSnapshot, data: Object.assign({ source: Vn.MediaInteraction }, t) })), styleSheetRuleCb: t => Vi(Yi({ type: Yn.IncrementalSnapshot, data: Object.assign({ source: Vn.StyleSheetRule }, t) })), styleDeclarationCb: t => Vi(Yi({ type: Yn.IncrementalSnapshot, data: Object.assign({ source: Vn.StyleDeclaration }, t) })), canvasMutationCb: F, fontCb: t => Vi(Yi({ type: Yn.IncrementalSnapshot, data: Object.assign({ source: Vn.Font }, t) })), blockClass: r, ignoreClass: o, ignoreSelector: c, maskTextClass: u, maskTextSelector: h, unmaskTextSelector: d, maskInputSelector: l, unmaskInputSelector: f, maskInputOptions: z, inlineStylesheet: p, sampling: S, recordCanvas: T, inlineImages: A, userTriggeredOnInput: E, collectFonts: I, doc: t, maskAllText: m, maskInputFn: b, maskTextFn: w, blockSelector: s, unblockSelector: a, slimDOMOptions: D, mirror: tr, iframeManager: j, shadowDomManager: B, canvasManager: U, plugins: (null === (e = null == C ? void 0 : C.filter((t => t.observer))) || void 0 === e ? void 0 : e.map((t => ({ observer: t.observer, options: t.options, callback: e => Vi(Yi({ type: Yn.Plugin, data: { plugin: t.name, payload: e } })) })))) || [] }, v) }; j.addLoadListener((n => { try { t.push(e(n.contentDocument)) } catch (t) { console.warn(t) } })); const n = () => { Qi(), t.push(e(document)) }; return "interactive" === document.readyState || "complete" === document.readyState ? n() : t.push(ii("load", (() => { Vi(Yi({ type: Yn.Load, data: {} })), n() }), window)), () => { t.forEach((t => t())) } } catch (t) { console.warn(t) } } er.addCustomEvent = (t, e) => { if (!Vi) throw new Error("please add custom event after start recording"); Vi(Yi({ type: Yn.Custom, data: { tag: t, payload: e } })) }, er.freezePage = () => { Ei.forEach((t => t.freeze())) }, er.takeFullSnapshot = t => { if (!Qi) throw new Error("please take full snapshot after start recording"); Qi(t) }, er.mirror = tr; const nr = ["name", "type", "startTime", "transferSize", "duration"]; function ir(t) { return function (e) { return nr.every((n => t[n] === e[n])) } } function rr(t) { const e = new PerformanceObserver((e => { const n = function (t, e) { const [n, i, r] = t.reduce(((t, e) => ("navigation" === e.entryType ? t[0].push(e) : "largest-contentful-paint" === e.entryType ? t[1].push(e) : t[2].push(e), t)), [[], [], []]), s = [], a = []; let o = i.length ? i[i.length - 1] : void 0; return e.forEach((t => { if ("largest-contentful-paint" !== t.entryType) if ("navigation" !== t.entryType) s.push(t); else { const e = t; t.duration > 0 && !n.find(ir(e)) && !a.find(ir(e)) && a.push(e) } else (!o || o.startTime < t.startTime) && (o = t) })), [...o ? [o] : [], ...n, ...r, ...s, ...a].sort(((t, e) => t.startTime - e.startTime)) }(t.performanceEvents, e.getEntries()); t.performanceEvents = n })); return ["element", "event", "first-input", "largest-contentful-paint", "layout-shift", "longtask", "navigation", "paint", "resource"].forEach((t => { try { e.observe({ type: t, buffered: !0 }) } catch (t) { } })), e } class sr { constructor() { this.events = [] } get hasEvents() { return this.events.length > 0 } destroy() { this.events = [] } async addEvent(t, e) { e ? this.events = [t] : this.events.push(t) } finish() { return new Promise((t => { const e = this.events; this.events = [], t(JSON.stringify(e)) })) } } class ar { constructor(t) { this.qt = t, this.Wt = 0 } ensureReady() { return this.Xt || (this.Xt = new Promise(((t, e) => { this.qt.addEventListener("message", (({ data: n }) => { n.success ? t() : e() }), { once: !0 }), this.qt.addEventListener("error", (t => { e(t) }), { once: !0 }) }))), this.Xt } destroy() { this.qt.terminate() } postMessage(t, e) { const n = this.Gt(); return new Promise(((i, r) => { const s = ({ data: e }) => { const a = e; a.method === t && a.id === n && (this.qt.removeEventListener("message", s), a.success ? i(a.response) : r(new Error("Error in compression worker"))) }; this.qt.addEventListener("message", s), this.qt.postMessage({ id: n, method: t, arg: e }) })) } Gt() { return this.Wt++ } } class or { constructor(t) { this.qt = new ar(t), this.hasEvents = !1 } ensureReady() { return this.qt.ensureReady() } destroy() { this.qt.destroy() } async addEvent(t, e) { return this.hasEvents = !0, e && await this.Jt(), this.Kt(t) } finish() { return this.Yt() } Kt(t) { return this.qt.postMessage("addEvent", JSON.stringify(t)) } async Yt() { const t = await this.qt.postMessage("finish"); return this.hasEvents = !1, t } Jt() { return this.qt.postMessage("clear") } } class cr { constructor(t) { this.Vt = new sr, this.Qt = new or(t), this.te = this.Vt, this.ee = this.ne() } get hasEvents() { return this.te.hasEvents } destroy() { this.Vt.destroy(), this.Qt.destroy() } addEvent(t, e) { return this.te.addEvent(t, e) } async finish() { return await this.ensureWorkerIsLoaded(), this.te.finish() } ensureWorkerIsLoaded() { return this.ee } async ne() { try { await this.Qt.ensureReady() } catch (t) { return } await this.ie() } async ie() { const { events: t } = this.Vt, e = []; for (const n of t) e.push(this.Qt.addEvent(n)); this.te = this.Qt; try { await Promise.all(e) } catch (t) { } } } function ur({ useCompression: t }) { if (t && window.Worker) try { const t = function () { const t = new Blob(['/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */\nfunction t(t){let e=t.length;for(;--e>=0;)t[e]=0}const e=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),a=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),i=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),n=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=new Array(576);t(s);const r=new Array(60);t(r);const o=new Array(512);t(o);const l=new Array(256);t(l);const h=new Array(29);t(h);const d=new Array(30);function _(t,e,a,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=a,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}let f,c,u;function w(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}t(d);const m=t=>t<256?o[t]:o[256+(t>>>7)],b=(t,e)=>{t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255},g=(t,e,a)=>{t.bi_valid>16-a?(t.bi_buf|=e<<t.bi_valid&65535,b(t,t.bi_buf),t.bi_buf=e>>16-t.bi_valid,t.bi_valid+=a-16):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=a)},p=(t,e,a)=>{g(t,a[2*e],a[2*e+1])},k=(t,e)=>{let a=0;do{a|=1&t,t>>>=1,a<<=1}while(--e>0);return a>>>1},v=(t,e,a)=>{const i=new Array(16);let n,s,r=0;for(n=1;n<=15;n++)r=r+a[n-1]<<1,i[n]=r;for(s=0;s<=e;s++){let e=t[2*s+1];0!==e&&(t[2*s]=k(i[e]++,e))}},y=t=>{let e;for(e=0;e<286;e++)t.dyn_ltree[2*e]=0;for(e=0;e<30;e++)t.dyn_dtree[2*e]=0;for(e=0;e<19;e++)t.bl_tree[2*e]=0;t.dyn_ltree[512]=1,t.opt_len=t.static_len=0,t.sym_next=t.matches=0},x=t=>{t.bi_valid>8?b(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0},z=(t,e,a,i)=>{const n=2*e,s=2*a;return t[n]<t[s]||t[n]===t[s]&&i[e]<=i[a]},A=(t,e,a)=>{const i=t.heap[a];let n=a<<1;for(;n<=t.heap_len&&(n<t.heap_len&&z(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!z(e,i,t.heap[n],t.depth));)t.heap[a]=t.heap[n],a=n,n<<=1;t.heap[a]=i},E=(t,i,n)=>{let s,r,o,_,f=0;if(0!==t.sym_next)do{s=255&t.pending_buf[t.sym_buf+f++],s+=(255&t.pending_buf[t.sym_buf+f++])<<8,r=t.pending_buf[t.sym_buf+f++],0===s?p(t,r,i):(o=l[r],p(t,o+256+1,i),_=e[o],0!==_&&(r-=h[o],g(t,r,_)),s--,o=m(s),p(t,o,n),_=a[o],0!==_&&(s-=d[o],g(t,s,_)))}while(f<t.sym_next);p(t,256,i)},R=(t,e)=>{const a=e.dyn_tree,i=e.stat_desc.static_tree,n=e.stat_desc.has_stree,s=e.stat_desc.elems;let r,o,l,h=-1;for(t.heap_len=0,t.heap_max=573,r=0;r<s;r++)0!==a[2*r]?(t.heap[++t.heap_len]=h=r,t.depth[r]=0):a[2*r+1]=0;for(;t.heap_len<2;)l=t.heap[++t.heap_len]=h<2?++h:0,a[2*l]=1,t.depth[l]=0,t.opt_len--,n&&(t.static_len-=i[2*l+1]);for(e.max_code=h,r=t.heap_len>>1;r>=1;r--)A(t,a,r);l=s;do{r=t.heap[1],t.heap[1]=t.heap[t.heap_len--],A(t,a,1),o=t.heap[1],t.heap[--t.heap_max]=r,t.heap[--t.heap_max]=o,a[2*l]=a[2*r]+a[2*o],t.depth[l]=(t.depth[r]>=t.depth[o]?t.depth[r]:t.depth[o])+1,a[2*r+1]=a[2*o+1]=l,t.heap[1]=l++,A(t,a,1)}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],((t,e)=>{const a=e.dyn_tree,i=e.max_code,n=e.stat_desc.static_tree,s=e.stat_desc.has_stree,r=e.stat_desc.extra_bits,o=e.stat_desc.extra_base,l=e.stat_desc.max_length;let h,d,_,f,c,u,w=0;for(f=0;f<=15;f++)t.bl_count[f]=0;for(a[2*t.heap[t.heap_max]+1]=0,h=t.heap_max+1;h<573;h++)d=t.heap[h],f=a[2*a[2*d+1]+1]+1,f>l&&(f=l,w++),a[2*d+1]=f,d>i||(t.bl_count[f]++,c=0,d>=o&&(c=r[d-o]),u=a[2*d],t.opt_len+=u*(f+c),s&&(t.static_len+=u*(n[2*d+1]+c)));if(0!==w){do{for(f=l-1;0===t.bl_count[f];)f--;t.bl_count[f]--,t.bl_count[f+1]+=2,t.bl_count[l]--,w-=2}while(w>0);for(f=l;0!==f;f--)for(d=t.bl_count[f];0!==d;)_=t.heap[--h],_>i||(a[2*_+1]!==f&&(t.opt_len+=(f-a[2*_+1])*a[2*_],a[2*_+1]=f),d--)}})(t,e),v(a,h,t.bl_count)},Z=(t,e,a)=>{let i,n,s=-1,r=e[1],o=0,l=7,h=4;for(0===r&&(l=138,h=3),e[2*(a+1)+1]=65535,i=0;i<=a;i++)n=r,r=e[2*(i+1)+1],++o<l&&n===r||(o<h?t.bl_tree[2*n]+=o:0!==n?(n!==s&&t.bl_tree[2*n]++,t.bl_tree[32]++):o<=10?t.bl_tree[34]++:t.bl_tree[36]++,o=0,s=n,0===r?(l=138,h=3):n===r?(l=6,h=3):(l=7,h=4))},U=(t,e,a)=>{let i,n,s=-1,r=e[1],o=0,l=7,h=4;for(0===r&&(l=138,h=3),i=0;i<=a;i++)if(n=r,r=e[2*(i+1)+1],!(++o<l&&n===r)){if(o<h)do{p(t,n,t.bl_tree)}while(0!=--o);else 0!==n?(n!==s&&(p(t,n,t.bl_tree),o--),p(t,16,t.bl_tree),g(t,o-3,2)):o<=10?(p(t,17,t.bl_tree),g(t,o-3,3)):(p(t,18,t.bl_tree),g(t,o-11,7));o=0,s=n,0===r?(l=138,h=3):n===r?(l=6,h=3):(l=7,h=4)}};let S=!1;const D=(t,e,a,i)=>{g(t,0+(i?1:0),3),x(t),b(t,a),b(t,~a),a&&t.pending_buf.set(t.window.subarray(e,e+a),t.pending),t.pending+=a};var T=(t,e,a,i)=>{let o,l,h=0;t.level>0?(2===t.strm.data_type&&(t.strm.data_type=(t=>{let e,a=4093624447;for(e=0;e<=31;e++,a>>>=1)if(1&a&&0!==t.dyn_ltree[2*e])return 0;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return 1;for(e=32;e<256;e++)if(0!==t.dyn_ltree[2*e])return 1;return 0})(t)),R(t,t.l_desc),R(t,t.d_desc),h=(t=>{let e;for(Z(t,t.dyn_ltree,t.l_desc.max_code),Z(t,t.dyn_dtree,t.d_desc.max_code),R(t,t.bl_desc),e=18;e>=3&&0===t.bl_tree[2*n[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e})(t),o=t.opt_len+3+7>>>3,l=t.static_len+3+7>>>3,l<=o&&(o=l)):o=l=a+5,a+4<=o&&-1!==e?D(t,e,a,i):4===t.strategy||l===o?(g(t,2+(i?1:0),3),E(t,s,r)):(g(t,4+(i?1:0),3),((t,e,a,i)=>{let s;for(g(t,e-257,5),g(t,a-1,5),g(t,i-4,4),s=0;s<i;s++)g(t,t.bl_tree[2*n[s]+1],3);U(t,t.dyn_ltree,e-1),U(t,t.dyn_dtree,a-1)})(t,t.l_desc.max_code+1,t.d_desc.max_code+1,h+1),E(t,t.dyn_ltree,t.dyn_dtree)),y(t),i&&x(t)},O={_tr_init:t=>{S||((()=>{let t,n,w,m,b;const g=new Array(16);for(w=0,m=0;m<28;m++)for(h[m]=w,t=0;t<1<<e[m];t++)l[w++]=m;for(l[w-1]=m,b=0,m=0;m<16;m++)for(d[m]=b,t=0;t<1<<a[m];t++)o[b++]=m;for(b>>=7;m<30;m++)for(d[m]=b<<7,t=0;t<1<<a[m]-7;t++)o[256+b++]=m;for(n=0;n<=15;n++)g[n]=0;for(t=0;t<=143;)s[2*t+1]=8,t++,g[8]++;for(;t<=255;)s[2*t+1]=9,t++,g[9]++;for(;t<=279;)s[2*t+1]=7,t++,g[7]++;for(;t<=287;)s[2*t+1]=8,t++,g[8]++;for(v(s,287,g),t=0;t<30;t++)r[2*t+1]=5,r[2*t]=k(t,5);f=new _(s,e,257,286,15),c=new _(r,a,0,30,15),u=new _(new Array(0),i,0,19,7)})(),S=!0),t.l_desc=new w(t.dyn_ltree,f),t.d_desc=new w(t.dyn_dtree,c),t.bl_desc=new w(t.bl_tree,u),t.bi_buf=0,t.bi_valid=0,y(t)},_tr_stored_block:D,_tr_flush_block:T,_tr_tally:(t,e,a)=>(t.pending_buf[t.sym_buf+t.sym_next++]=e,t.pending_buf[t.sym_buf+t.sym_next++]=e>>8,t.pending_buf[t.sym_buf+t.sym_next++]=a,0===e?t.dyn_ltree[2*a]++:(t.matches++,e--,t.dyn_ltree[2*(l[a]+256+1)]++,t.dyn_dtree[2*m(e)]++),t.sym_next===t.sym_end),_tr_align:t=>{g(t,2,3),p(t,256,s),(t=>{16===t.bi_valid?(b(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)})(t)}};var F=(t,e,a,i)=>{let n=65535&t|0,s=t>>>16&65535|0,r=0;for(;0!==a;){r=a>2e3?2e3:a,a-=r;do{n=n+e[i++]|0,s=s+n|0}while(--r);n%=65521,s%=65521}return n|s<<16|0};const L=new Uint32Array((()=>{let t,e=[];for(var a=0;a<256;a++){t=a;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[a]=t}return e})());var N=(t,e,a,i)=>{const n=L,s=i+a;t^=-1;for(let a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t},I={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},B={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:C,_tr_stored_block:H,_tr_flush_block:M,_tr_tally:j,_tr_align:K}=O,{Z_NO_FLUSH:P,Z_PARTIAL_FLUSH:Y,Z_FULL_FLUSH:G,Z_FINISH:X,Z_BLOCK:W,Z_OK:q,Z_STREAM_END:J,Z_STREAM_ERROR:Q,Z_DATA_ERROR:V,Z_BUF_ERROR:$,Z_DEFAULT_COMPRESSION:tt,Z_FILTERED:et,Z_HUFFMAN_ONLY:at,Z_RLE:it,Z_FIXED:nt,Z_DEFAULT_STRATEGY:st,Z_UNKNOWN:rt,Z_DEFLATED:ot}=B,lt=(t,e)=>(t.msg=I[e],e),ht=t=>2*t-(t>4?9:0),dt=t=>{let e=t.length;for(;--e>=0;)t[e]=0},_t=t=>{let e,a,i,n=t.w_size;e=t.hash_size,i=e;do{a=t.head[--i],t.head[i]=a>=n?a-n:0}while(--e);e=n,i=e;do{a=t.prev[--i],t.prev[i]=a>=n?a-n:0}while(--e)};let ft=(t,e,a)=>(e<<t.hash_shift^a)&t.hash_mask;const ct=t=>{const e=t.state;let a=e.pending;a>t.avail_out&&(a=t.avail_out),0!==a&&(t.output.set(e.pending_buf.subarray(e.pending_out,e.pending_out+a),t.next_out),t.next_out+=a,e.pending_out+=a,t.total_out+=a,t.avail_out-=a,e.pending-=a,0===e.pending&&(e.pending_out=0))},ut=(t,e)=>{M(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,ct(t.strm)},wt=(t,e)=>{t.pending_buf[t.pending++]=e},mt=(t,e)=>{t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e},bt=(t,e,a,i)=>{let n=t.avail_in;return n>i&&(n=i),0===n?0:(t.avail_in-=n,e.set(t.input.subarray(t.next_in,t.next_in+n),a),1===t.state.wrap?t.adler=F(t.adler,e,n,a):2===t.state.wrap&&(t.adler=N(t.adler,e,n,a)),t.next_in+=n,t.total_in+=n,n)},gt=(t,e)=>{let a,i,n=t.max_chain_length,s=t.strstart,r=t.prev_length,o=t.nice_match;const l=t.strstart>t.w_size-262?t.strstart-(t.w_size-262):0,h=t.window,d=t.w_mask,_=t.prev,f=t.strstart+258;let c=h[s+r-1],u=h[s+r];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do{if(a=e,h[a+r]===u&&h[a+r-1]===c&&h[a]===h[s]&&h[++a]===h[s+1]){s+=2,a++;do{}while(h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&h[++s]===h[++a]&&s<f);if(i=258-(f-s),s=f-258,i>r){if(t.match_start=e,r=i,i>=o)break;c=h[s+r-1],u=h[s+r]}}}while((e=_[e&d])>l&&0!=--n);return r<=t.lookahead?r:t.lookahead},pt=t=>{const e=t.w_size;let a,i,n;do{if(i=t.window_size-t.lookahead-t.strstart,t.strstart>=e+(e-262)&&(t.window.set(t.window.subarray(e,e+e-i),0),t.match_start-=e,t.strstart-=e,t.block_start-=e,t.insert>t.strstart&&(t.insert=t.strstart),_t(t),i+=e),0===t.strm.avail_in)break;if(a=bt(t.strm,t.window,t.strstart+t.lookahead,i),t.lookahead+=a,t.lookahead+t.insert>=3)for(n=t.strstart-t.insert,t.ins_h=t.window[n],t.ins_h=ft(t,t.ins_h,t.window[n+1]);t.insert&&(t.ins_h=ft(t,t.ins_h,t.window[n+3-1]),t.prev[n&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=n,n++,t.insert--,!(t.lookahead+t.insert<3)););}while(t.lookahead<262&&0!==t.strm.avail_in)},kt=(t,e)=>{let a,i,n,s=t.pending_buf_size-5>t.w_size?t.w_size:t.pending_buf_size-5,r=0,o=t.strm.avail_in;do{if(a=65535,n=t.bi_valid+42>>3,t.strm.avail_out<n)break;if(n=t.strm.avail_out-n,i=t.strstart-t.block_start,a>i+t.strm.avail_in&&(a=i+t.strm.avail_in),a>n&&(a=n),a<s&&(0===a&&e!==X||e===P||a!==i+t.strm.avail_in))break;r=e===X&&a===i+t.strm.avail_in?1:0,H(t,0,0,r),t.pending_buf[t.pending-4]=a,t.pending_buf[t.pending-3]=a>>8,t.pending_buf[t.pending-2]=~a,t.pending_buf[t.pending-1]=~a>>8,ct(t.strm),i&&(i>a&&(i=a),t.strm.output.set(t.window.subarray(t.block_start,t.block_start+i),t.strm.next_out),t.strm.next_out+=i,t.strm.avail_out-=i,t.strm.total_out+=i,t.block_start+=i,a-=i),a&&(bt(t.strm,t.strm.output,t.strm.next_out,a),t.strm.next_out+=a,t.strm.avail_out-=a,t.strm.total_out+=a)}while(0===r);return o-=t.strm.avail_in,o&&(o>=t.w_size?(t.matches=2,t.window.set(t.strm.input.subarray(t.strm.next_in-t.w_size,t.strm.next_in),0),t.strstart=t.w_size,t.insert=t.strstart):(t.window_size-t.strstart<=o&&(t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,t.insert>t.strstart&&(t.insert=t.strstart)),t.window.set(t.strm.input.subarray(t.strm.next_in-o,t.strm.next_in),t.strstart),t.strstart+=o,t.insert+=o>t.w_size-t.insert?t.w_size-t.insert:o),t.block_start=t.strstart),t.high_water<t.strstart&&(t.high_water=t.strstart),r?4:e!==P&&e!==X&&0===t.strm.avail_in&&t.strstart===t.block_start?2:(n=t.window_size-t.strstart,t.strm.avail_in>n&&t.block_start>=t.w_size&&(t.block_start-=t.w_size,t.strstart-=t.w_size,t.window.set(t.window.subarray(t.w_size,t.w_size+t.strstart),0),t.matches<2&&t.matches++,n+=t.w_size,t.insert>t.strstart&&(t.insert=t.strstart)),n>t.strm.avail_in&&(n=t.strm.avail_in),n&&(bt(t.strm,t.window,t.strstart,n),t.strstart+=n,t.insert+=n>t.w_size-t.insert?t.w_size-t.insert:n),t.high_water<t.strstart&&(t.high_water=t.strstart),n=t.bi_valid+42>>3,n=t.pending_buf_size-n>65535?65535:t.pending_buf_size-n,s=n>t.w_size?t.w_size:n,i=t.strstart-t.block_start,(i>=s||(i||e===X)&&e!==P&&0===t.strm.avail_in&&i<=n)&&(a=i>n?n:i,r=e===X&&0===t.strm.avail_in&&a===i?1:0,H(t,t.block_start,a,r),t.block_start+=a,ct(t.strm)),r?3:1)},vt=(t,e)=>{let a,i;for(;;){if(t.lookahead<262){if(pt(t),t.lookahead<262&&e===P)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=ft(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==a&&t.strstart-a<=t.w_size-262&&(t.match_length=gt(t,a)),t.match_length>=3)if(i=j(t,t.strstart-t.match_start,t.match_length-3),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=3){t.match_length--;do{t.strstart++,t.ins_h=ft(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart}while(0!=--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=ft(t,t.ins_h,t.window[t.strstart+1]);else i=j(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(ut(t,!1),0===t.strm.avail_out))return 1}return t.insert=t.strstart<2?t.strstart:2,e===X?(ut(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(ut(t,!1),0===t.strm.avail_out)?1:2},yt=(t,e)=>{let a,i,n;for(;;){if(t.lookahead<262){if(pt(t),t.lookahead<262&&e===P)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=ft(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=2,0!==a&&t.prev_length<t.max_lazy_match&&t.strstart-a<=t.w_size-262&&(t.match_length=gt(t,a),t.match_length<=5&&(t.strategy===et||3===t.match_length&&t.strstart-t.match_start>4096)&&(t.match_length=2)),t.prev_length>=3&&t.match_length<=t.prev_length){n=t.strstart+t.lookahead-3,i=j(t,t.strstart-1-t.prev_match,t.prev_length-3),t.lookahead-=t.prev_length-1,t.prev_length-=2;do{++t.strstart<=n&&(t.ins_h=ft(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart)}while(0!=--t.prev_length);if(t.match_available=0,t.match_length=2,t.strstart++,i&&(ut(t,!1),0===t.strm.avail_out))return 1}else if(t.match_available){if(i=j(t,0,t.window[t.strstart-1]),i&&ut(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return 1}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=j(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<2?t.strstart:2,e===X?(ut(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(ut(t,!1),0===t.strm.avail_out)?1:2};function xt(t,e,a,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=a,this.max_chain=i,this.func=n}const zt=[new xt(0,0,0,0,kt),new xt(4,4,8,4,vt),new xt(4,5,16,8,vt),new xt(4,6,32,32,vt),new xt(4,4,16,16,yt),new xt(8,16,32,32,yt),new xt(8,16,128,128,yt),new xt(8,32,128,256,yt),new xt(32,128,258,1024,yt),new xt(32,258,258,4096,yt)];function At(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=ot,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),dt(this.dyn_ltree),dt(this.dyn_dtree),dt(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),dt(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),dt(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const Et=t=>{if(!t)return 1;const e=t.state;return!e||e.strm!==t||42!==e.status&&57!==e.status&&69!==e.status&&73!==e.status&&91!==e.status&&103!==e.status&&113!==e.status&&666!==e.status?1:0},Rt=t=>{if(Et(t))return lt(t,Q);t.total_in=t.total_out=0,t.data_type=rt;const e=t.state;return e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=2===e.wrap?57:e.wrap?42:113,t.adler=2===e.wrap?0:1,e.last_flush=-2,C(e),q},Zt=t=>{const e=Rt(t);var a;return e===q&&((a=t.state).window_size=2*a.w_size,dt(a.head),a.max_lazy_match=zt[a.level].max_lazy,a.good_match=zt[a.level].good_length,a.nice_match=zt[a.level].nice_length,a.max_chain_length=zt[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=2,a.match_available=0,a.ins_h=0),e},Ut=(t,e,a,i,n,s)=>{if(!t)return Q;let r=1;if(e===tt&&(e=6),i<0?(r=0,i=-i):i>15&&(r=2,i-=16),n<1||n>9||a!==ot||i<8||i>15||e<0||e>9||s<0||s>nt||8===i&&1!==r)return lt(t,Q);8===i&&(i=9);const o=new At;return t.state=o,o.strm=t,o.status=42,o.wrap=r,o.gzhead=null,o.w_bits=i,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=n+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+3-1)/3),o.window=new Uint8Array(2*o.w_size),o.head=new Uint16Array(o.hash_size),o.prev=new Uint16Array(o.w_size),o.lit_bufsize=1<<n+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new Uint8Array(o.pending_buf_size),o.sym_buf=o.lit_bufsize,o.sym_end=3*(o.lit_bufsize-1),o.level=e,o.strategy=s,o.method=a,Zt(t)};var St={deflateInit:(t,e)=>Ut(t,e,ot,15,8,st),deflateInit2:Ut,deflateReset:Zt,deflateResetKeep:Rt,deflateSetHeader:(t,e)=>Et(t)||2!==t.state.wrap?Q:(t.state.gzhead=e,q),deflate:(t,e)=>{if(Et(t)||e>W||e<0)return t?lt(t,Q):Q;const a=t.state;if(!t.output||0!==t.avail_in&&!t.input||666===a.status&&e!==X)return lt(t,0===t.avail_out?$:Q);const i=a.last_flush;if(a.last_flush=e,0!==a.pending){if(ct(t),0===t.avail_out)return a.last_flush=-1,q}else if(0===t.avail_in&&ht(e)<=ht(i)&&e!==X)return lt(t,$);if(666===a.status&&0!==t.avail_in)return lt(t,$);if(42===a.status&&0===a.wrap&&(a.status=113),42===a.status){let e=ot+(a.w_bits-8<<4)<<8,i=-1;if(i=a.strategy>=at||a.level<2?0:a.level<6?1:6===a.level?2:3,e|=i<<6,0!==a.strstart&&(e|=32),e+=31-e%31,mt(a,e),0!==a.strstart&&(mt(a,t.adler>>>16),mt(a,65535&t.adler)),t.adler=1,a.status=113,ct(t),0!==a.pending)return a.last_flush=-1,q}if(57===a.status)if(t.adler=0,wt(a,31),wt(a,139),wt(a,8),a.gzhead)wt(a,(a.gzhead.text?1:0)+(a.gzhead.hcrc?2:0)+(a.gzhead.extra?4:0)+(a.gzhead.name?8:0)+(a.gzhead.comment?16:0)),wt(a,255&a.gzhead.time),wt(a,a.gzhead.time>>8&255),wt(a,a.gzhead.time>>16&255),wt(a,a.gzhead.time>>24&255),wt(a,9===a.level?2:a.strategy>=at||a.level<2?4:0),wt(a,255&a.gzhead.os),a.gzhead.extra&&a.gzhead.extra.length&&(wt(a,255&a.gzhead.extra.length),wt(a,a.gzhead.extra.length>>8&255)),a.gzhead.hcrc&&(t.adler=N(t.adler,a.pending_buf,a.pending,0)),a.gzindex=0,a.status=69;else if(wt(a,0),wt(a,0),wt(a,0),wt(a,0),wt(a,0),wt(a,9===a.level?2:a.strategy>=at||a.level<2?4:0),wt(a,3),a.status=113,ct(t),0!==a.pending)return a.last_flush=-1,q;if(69===a.status){if(a.gzhead.extra){let e=a.pending,i=(65535&a.gzhead.extra.length)-a.gzindex;for(;a.pending+i>a.pending_buf_size;){let n=a.pending_buf_size-a.pending;if(a.pending_buf.set(a.gzhead.extra.subarray(a.gzindex,a.gzindex+n),a.pending),a.pending=a.pending_buf_size,a.gzhead.hcrc&&a.pending>e&&(t.adler=N(t.adler,a.pending_buf,a.pending-e,e)),a.gzindex+=n,ct(t),0!==a.pending)return a.last_flush=-1,q;e=0,i-=n}let n=new Uint8Array(a.gzhead.extra);a.pending_buf.set(n.subarray(a.gzindex,a.gzindex+i),a.pending),a.pending+=i,a.gzhead.hcrc&&a.pending>e&&(t.adler=N(t.adler,a.pending_buf,a.pending-e,e)),a.gzindex=0}a.status=73}if(73===a.status){if(a.gzhead.name){let e,i=a.pending;do{if(a.pending===a.pending_buf_size){if(a.gzhead.hcrc&&a.pending>i&&(t.adler=N(t.adler,a.pending_buf,a.pending-i,i)),ct(t),0!==a.pending)return a.last_flush=-1,q;i=0}e=a.gzindex<a.gzhead.name.length?255&a.gzhead.name.charCodeAt(a.gzindex++):0,wt(a,e)}while(0!==e);a.gzhead.hcrc&&a.pending>i&&(t.adler=N(t.adler,a.pending_buf,a.pending-i,i)),a.gzindex=0}a.status=91}if(91===a.status){if(a.gzhead.comment){let e,i=a.pending;do{if(a.pending===a.pending_buf_size){if(a.gzhead.hcrc&&a.pending>i&&(t.adler=N(t.adler,a.pending_buf,a.pending-i,i)),ct(t),0!==a.pending)return a.last_flush=-1,q;i=0}e=a.gzindex<a.gzhead.comment.length?255&a.gzhead.comment.charCodeAt(a.gzindex++):0,wt(a,e)}while(0!==e);a.gzhead.hcrc&&a.pending>i&&(t.adler=N(t.adler,a.pending_buf,a.pending-i,i))}a.status=103}if(103===a.status){if(a.gzhead.hcrc){if(a.pending+2>a.pending_buf_size&&(ct(t),0!==a.pending))return a.last_flush=-1,q;wt(a,255&t.adler),wt(a,t.adler>>8&255),t.adler=0}if(a.status=113,ct(t),0!==a.pending)return a.last_flush=-1,q}if(0!==t.avail_in||0!==a.lookahead||e!==P&&666!==a.status){let i=0===a.level?kt(a,e):a.strategy===at?((t,e)=>{let a;for(;;){if(0===t.lookahead&&(pt(t),0===t.lookahead)){if(e===P)return 1;break}if(t.match_length=0,a=j(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,a&&(ut(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===X?(ut(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(ut(t,!1),0===t.strm.avail_out)?1:2})(a,e):a.strategy===it?((t,e)=>{let a,i,n,s;const r=t.window;for(;;){if(t.lookahead<=258){if(pt(t),t.lookahead<=258&&e===P)return 1;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=3&&t.strstart>0&&(n=t.strstart-1,i=r[n],i===r[++n]&&i===r[++n]&&i===r[++n])){s=t.strstart+258;do{}while(i===r[++n]&&i===r[++n]&&i===r[++n]&&i===r[++n]&&i===r[++n]&&i===r[++n]&&i===r[++n]&&i===r[++n]&&n<s);t.match_length=258-(s-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=3?(a=j(t,1,t.match_length-3),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(a=j(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),a&&(ut(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===X?(ut(t,!0),0===t.strm.avail_out?3:4):t.sym_next&&(ut(t,!1),0===t.strm.avail_out)?1:2})(a,e):zt[a.level].func(a,e);if(3!==i&&4!==i||(a.status=666),1===i||3===i)return 0===t.avail_out&&(a.last_flush=-1),q;if(2===i&&(e===Y?K(a):e!==W&&(H(a,0,0,!1),e===G&&(dt(a.head),0===a.lookahead&&(a.strstart=0,a.block_start=0,a.insert=0))),ct(t),0===t.avail_out))return a.last_flush=-1,q}return e!==X?q:a.wrap<=0?J:(2===a.wrap?(wt(a,255&t.adler),wt(a,t.adler>>8&255),wt(a,t.adler>>16&255),wt(a,t.adler>>24&255),wt(a,255&t.total_in),wt(a,t.total_in>>8&255),wt(a,t.total_in>>16&255),wt(a,t.total_in>>24&255)):(mt(a,t.adler>>>16),mt(a,65535&t.adler)),ct(t),a.wrap>0&&(a.wrap=-a.wrap),0!==a.pending?q:J)},deflateEnd:t=>{if(Et(t))return Q;const e=t.state.status;return t.state=null,113===e?lt(t,V):q},deflateSetDictionary:(t,e)=>{let a=e.length;if(Et(t))return Q;const i=t.state,n=i.wrap;if(2===n||1===n&&42!==i.status||i.lookahead)return Q;if(1===n&&(t.adler=F(t.adler,e,a,0)),i.wrap=0,a>=i.w_size){0===n&&(dt(i.head),i.strstart=0,i.block_start=0,i.insert=0);let t=new Uint8Array(i.w_size);t.set(e.subarray(a-i.w_size,a),0),e=t,a=i.w_size}const s=t.avail_in,r=t.next_in,o=t.input;for(t.avail_in=a,t.next_in=0,t.input=e,pt(i);i.lookahead>=3;){let t=i.strstart,e=i.lookahead-2;do{i.ins_h=ft(i,i.ins_h,i.window[t+3-1]),i.prev[t&i.w_mask]=i.head[i.ins_h],i.head[i.ins_h]=t,t++}while(--e);i.strstart=t,i.lookahead=2,pt(i)}return i.strstart+=i.lookahead,i.block_start=i.strstart,i.insert=i.lookahead,i.lookahead=0,i.match_length=i.prev_length=2,i.match_available=0,t.next_in=r,t.input=o,t.avail_in=s,i.wrap=n,q},deflateInfo:"pako deflate (from Nodeca project)"};const Dt=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var Tt=function(t){const e=Array.prototype.slice.call(arguments,1);for(;e.length;){const a=e.shift();if(a){if("object"!=typeof a)throw new TypeError(a+"must be non-object");for(const e in a)Dt(a,e)&&(t[e]=a[e])}}return t},Ot=t=>{let e=0;for(let a=0,i=t.length;a<i;a++)e+=t[a].length;const a=new Uint8Array(e);for(let e=0,i=0,n=t.length;e<n;e++){let n=t[e];a.set(n,i),i+=n.length}return a};let Ft=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){Ft=!1}const Lt=new Uint8Array(256);for(let t=0;t<256;t++)Lt[t]=t>=252?6:t>=248?5:t>=240?4:t>=224?3:t>=192?2:1;Lt[254]=Lt[254]=1;var Nt=t=>{if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(t);let e,a,i,n,s,r=t.length,o=0;for(n=0;n<r;n++)a=t.charCodeAt(n),55296==(64512&a)&&n+1<r&&(i=t.charCodeAt(n+1),56320==(64512&i)&&(a=65536+(a-55296<<10)+(i-56320),n++)),o+=a<128?1:a<2048?2:a<65536?3:4;for(e=new Uint8Array(o),s=0,n=0;s<o;n++)a=t.charCodeAt(n),55296==(64512&a)&&n+1<r&&(i=t.charCodeAt(n+1),56320==(64512&i)&&(a=65536+(a-55296<<10)+(i-56320),n++)),a<128?e[s++]=a:a<2048?(e[s++]=192|a>>>6,e[s++]=128|63&a):a<65536?(e[s++]=224|a>>>12,e[s++]=128|a>>>6&63,e[s++]=128|63&a):(e[s++]=240|a>>>18,e[s++]=128|a>>>12&63,e[s++]=128|a>>>6&63,e[s++]=128|63&a);return e},It=(t,e)=>{const a=e||t.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(t.subarray(0,e));let i,n;const s=new Array(2*a);for(n=0,i=0;i<a;){let e=t[i++];if(e<128){s[n++]=e;continue}let r=Lt[e];if(r>4)s[n++]=65533,i+=r-1;else{for(e&=2===r?31:3===r?15:7;r>1&&i<a;)e=e<<6|63&t[i++],r--;r>1?s[n++]=65533:e<65536?s[n++]=e:(e-=65536,s[n++]=55296|e>>10&1023,s[n++]=56320|1023&e)}}return((t,e)=>{if(e<65534&&t.subarray&&Ft)return String.fromCharCode.apply(null,t.length===e?t:t.subarray(0,e));let a="";for(let i=0;i<e;i++)a+=String.fromCharCode(t[i]);return a})(s,n)},Bt=(t,e)=>{(e=e||t.length)>t.length&&(e=t.length);let a=e-1;for(;a>=0&&128==(192&t[a]);)a--;return a<0||0===a?e:a+Lt[t[a]]>e?a:e};var Ct=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0};const Ht=Object.prototype.toString,{Z_NO_FLUSH:Mt,Z_SYNC_FLUSH:jt,Z_FULL_FLUSH:Kt,Z_FINISH:Pt,Z_OK:Yt,Z_STREAM_END:Gt,Z_DEFAULT_COMPRESSION:Xt,Z_DEFAULT_STRATEGY:Wt,Z_DEFLATED:qt}=B;function Jt(t){this.options=Tt({level:Xt,method:qt,chunkSize:16384,windowBits:15,memLevel:8,strategy:Wt},t||{});let e=this.options;e.raw&&e.windowBits>0?e.windowBits=-e.windowBits:e.gzip&&e.windowBits>0&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Ct,this.strm.avail_out=0;let a=St.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(a!==Yt)throw new Error(I[a]);if(e.header&&St.deflateSetHeader(this.strm,e.header),e.dictionary){let t;if(t="string"==typeof e.dictionary?Nt(e.dictionary):"[object ArrayBuffer]"===Ht.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,a=St.deflateSetDictionary(this.strm,t),a!==Yt)throw new Error(I[a]);this._dict_set=!0}}function Qt(t,e){const a=new Jt(e);if(a.push(t,!0),a.err)throw a.msg||I[a.err];return a.result}Jt.prototype.push=function(t,e){const a=this.strm,i=this.options.chunkSize;let n,s;if(this.ended)return!1;for(s=e===~~e?e:!0===e?Pt:Mt,"string"==typeof t?a.input=Nt(t):"[object ArrayBuffer]"===Ht.call(t)?a.input=new Uint8Array(t):a.input=t,a.next_in=0,a.avail_in=a.input.length;;)if(0===a.avail_out&&(a.output=new Uint8Array(i),a.next_out=0,a.avail_out=i),(s===jt||s===Kt)&&a.avail_out<=6)this.onData(a.output.subarray(0,a.next_out)),a.avail_out=0;else{if(n=St.deflate(a,s),n===Gt)return a.next_out>0&&this.onData(a.output.subarray(0,a.next_out)),n=St.deflateEnd(this.strm),this.onEnd(n),this.ended=!0,n===Yt;if(0!==a.avail_out){if(s>0&&a.next_out>0)this.onData(a.output.subarray(0,a.next_out)),a.avail_out=0;else if(0===a.avail_in)break}else this.onData(a.output)}return!0},Jt.prototype.onData=function(t){this.chunks.push(t)},Jt.prototype.onEnd=function(t){t===Yt&&(this.result=Ot(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};var Vt={Deflate:Jt,deflate:Qt,deflateRaw:function(t,e){return(e=e||{}).raw=!0,Qt(t,e)},gzip:function(t,e){return(e=e||{}).gzip=!0,Qt(t,e)},constants:B};var $t=function(t,e){let a,i,n,s,r,o,l,h,d,_,f,c,u,w,m,b,g,p,k,v,y,x,z,A;const E=t.state;a=t.next_in,z=t.input,i=a+(t.avail_in-5),n=t.next_out,A=t.output,s=n-(e-t.avail_out),r=n+(t.avail_out-257),o=E.dmax,l=E.wsize,h=E.whave,d=E.wnext,_=E.window,f=E.hold,c=E.bits,u=E.lencode,w=E.distcode,m=(1<<E.lenbits)-1,b=(1<<E.distbits)-1;t:do{c<15&&(f+=z[a++]<<c,c+=8,f+=z[a++]<<c,c+=8),g=u[f&m];e:for(;;){if(p=g>>>24,f>>>=p,c-=p,p=g>>>16&255,0===p)A[n++]=65535&g;else{if(!(16&p)){if(0==(64&p)){g=u[(65535&g)+(f&(1<<p)-1)];continue e}if(32&p){E.mode=16191;break t}t.msg="invalid literal/length code",E.mode=16209;break t}k=65535&g,p&=15,p&&(c<p&&(f+=z[a++]<<c,c+=8),k+=f&(1<<p)-1,f>>>=p,c-=p),c<15&&(f+=z[a++]<<c,c+=8,f+=z[a++]<<c,c+=8),g=w[f&b];a:for(;;){if(p=g>>>24,f>>>=p,c-=p,p=g>>>16&255,!(16&p)){if(0==(64&p)){g=w[(65535&g)+(f&(1<<p)-1)];continue a}t.msg="invalid distance code",E.mode=16209;break t}if(v=65535&g,p&=15,c<p&&(f+=z[a++]<<c,c+=8,c<p&&(f+=z[a++]<<c,c+=8)),v+=f&(1<<p)-1,v>o){t.msg="invalid distance too far back",E.mode=16209;break t}if(f>>>=p,c-=p,p=n-s,v>p){if(p=v-p,p>h&&E.sane){t.msg="invalid distance too far back",E.mode=16209;break t}if(y=0,x=_,0===d){if(y+=l-p,p<k){k-=p;do{A[n++]=_[y++]}while(--p);y=n-v,x=A}}else if(d<p){if(y+=l+d-p,p-=d,p<k){k-=p;do{A[n++]=_[y++]}while(--p);if(y=0,d<k){p=d,k-=p;do{A[n++]=_[y++]}while(--p);y=n-v,x=A}}}else if(y+=d-p,p<k){k-=p;do{A[n++]=_[y++]}while(--p);y=n-v,x=A}for(;k>2;)A[n++]=x[y++],A[n++]=x[y++],A[n++]=x[y++],k-=3;k&&(A[n++]=x[y++],k>1&&(A[n++]=x[y++]))}else{y=n-v;do{A[n++]=A[y++],A[n++]=A[y++],A[n++]=A[y++],k-=3}while(k>2);k&&(A[n++]=A[y++],k>1&&(A[n++]=A[y++]))}break}}break}}while(a<i&&n<r);k=c>>3,a-=k,c-=k<<3,f&=(1<<c)-1,t.next_in=a,t.next_out=n,t.avail_in=a<i?i-a+5:5-(a-i),t.avail_out=n<r?r-n+257:257-(n-r),E.hold=f,E.bits=c};const te=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),ee=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),ae=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),ie=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var ne=(t,e,a,i,n,s,r,o)=>{const l=o.bits;let h,d,_,f,c,u,w=0,m=0,b=0,g=0,p=0,k=0,v=0,y=0,x=0,z=0,A=null;const E=new Uint16Array(16),R=new Uint16Array(16);let Z,U,S,D=null;for(w=0;w<=15;w++)E[w]=0;for(m=0;m<i;m++)E[e[a+m]]++;for(p=l,g=15;g>=1&&0===E[g];g--);if(p>g&&(p=g),0===g)return n[s++]=20971520,n[s++]=20971520,o.bits=1,0;for(b=1;b<g&&0===E[b];b++);for(p<b&&(p=b),y=1,w=1;w<=15;w++)if(y<<=1,y-=E[w],y<0)return-1;if(y>0&&(0===t||1!==g))return-1;for(R[1]=0,w=1;w<15;w++)R[w+1]=R[w]+E[w];for(m=0;m<i;m++)0!==e[a+m]&&(r[R[e[a+m]]++]=m);if(0===t?(A=D=r,u=20):1===t?(A=te,D=ee,u=257):(A=ae,D=ie,u=0),z=0,m=0,w=b,c=s,k=p,v=0,_=-1,x=1<<p,f=x-1,1===t&&x>852||2===t&&x>592)return 1;for(;;){Z=w-v,r[m]+1<u?(U=0,S=r[m]):r[m]>=u?(U=D[r[m]-u],S=A[r[m]-u]):(U=96,S=0),h=1<<w-v,d=1<<k,b=d;do{d-=h,n[c+(z>>v)+d]=Z<<24|U<<16|S|0}while(0!==d);for(h=1<<w-1;z&h;)h>>=1;if(0!==h?(z&=h-1,z+=h):z=0,m++,0==--E[w]){if(w===g)break;w=e[a+r[m]]}if(w>p&&(z&f)!==_){for(0===v&&(v=p),c+=b,k=w-v,y=1<<k;k+v<g&&(y-=E[k+v],!(y<=0));)k++,y<<=1;if(x+=1<<k,1===t&&x>852||2===t&&x>592)return 1;_=z&f,n[_]=p<<24|k<<16|c-s|0}}return 0!==z&&(n[c+z]=w-v<<24|64<<16|0),o.bits=p,0};const{Z_FINISH:se,Z_BLOCK:re,Z_TREES:oe,Z_OK:le,Z_STREAM_END:he,Z_NEED_DICT:de,Z_STREAM_ERROR:_e,Z_DATA_ERROR:fe,Z_MEM_ERROR:ce,Z_BUF_ERROR:ue,Z_DEFLATED:we}=B,me=16209,be=t=>(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24);function ge(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const pe=t=>{if(!t)return 1;const e=t.state;return!e||e.strm!==t||e.mode<16180||e.mode>16211?1:0},ke=t=>{if(pe(t))return _e;const e=t.state;return t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=16180,e.last=0,e.havedict=0,e.flags=-1,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new Int32Array(852),e.distcode=e.distdyn=new Int32Array(592),e.sane=1,e.back=-1,le},ve=t=>{if(pe(t))return _e;const e=t.state;return e.wsize=0,e.whave=0,e.wnext=0,ke(t)},ye=(t,e)=>{let a;if(pe(t))return _e;const i=t.state;return e<0?(a=0,e=-e):(a=5+(e>>4),e<48&&(e&=15)),e&&(e<8||e>15)?_e:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=a,i.wbits=e,ve(t))},xe=(t,e)=>{if(!t)return _e;const a=new ge;t.state=a,a.strm=t,a.window=null,a.mode=16180;const i=ye(t,e);return i!==le&&(t.state=null),i};let ze,Ae,Ee=!0;const Re=t=>{if(Ee){ze=new Int32Array(512),Ae=new Int32Array(32);let e=0;for(;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(ne(1,t.lens,0,288,ze,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;ne(2,t.lens,0,32,Ae,0,t.work,{bits:5}),Ee=!1}t.lencode=ze,t.lenbits=9,t.distcode=Ae,t.distbits=5},Ze=(t,e,a,i)=>{let n;const s=t.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new Uint8Array(s.wsize)),i>=s.wsize?(s.window.set(e.subarray(a-s.wsize,a),0),s.wnext=0,s.whave=s.wsize):(n=s.wsize-s.wnext,n>i&&(n=i),s.window.set(e.subarray(a-i,a-i+n),s.wnext),(i-=n)?(s.window.set(e.subarray(a-i,a),0),s.wnext=i,s.whave=s.wsize):(s.wnext+=n,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=n))),0};var Ue={inflateReset:ve,inflateReset2:ye,inflateResetKeep:ke,inflateInit:t=>xe(t,15),inflateInit2:xe,inflate:(t,e)=>{let a,i,n,s,r,o,l,h,d,_,f,c,u,w,m,b,g,p,k,v,y,x,z=0;const A=new Uint8Array(4);let E,R;const Z=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(pe(t)||!t.output||!t.input&&0!==t.avail_in)return _e;a=t.state,16191===a.mode&&(a.mode=16192),r=t.next_out,n=t.output,l=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,h=a.hold,d=a.bits,_=o,f=l,x=le;t:for(;;)switch(a.mode){case 16180:if(0===a.wrap){a.mode=16192;break}for(;d<16;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(2&a.wrap&&35615===h){0===a.wbits&&(a.wbits=15),a.check=0,A[0]=255&h,A[1]=h>>>8&255,a.check=N(a.check,A,2,0),h=0,d=0,a.mode=16181;break}if(a.head&&(a.head.done=!1),!(1&a.wrap)||(((255&h)<<8)+(h>>8))%31){t.msg="incorrect header check",a.mode=me;break}if((15&h)!==we){t.msg="unknown compression method",a.mode=me;break}if(h>>>=4,d-=4,y=8+(15&h),0===a.wbits&&(a.wbits=y),y>15||y>a.wbits){t.msg="invalid window size",a.mode=me;break}a.dmax=1<<a.wbits,a.flags=0,t.adler=a.check=1,a.mode=512&h?16189:16191,h=0,d=0;break;case 16181:for(;d<16;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(a.flags=h,(255&a.flags)!==we){t.msg="unknown compression method",a.mode=me;break}if(57344&a.flags){t.msg="unknown header flags set",a.mode=me;break}a.head&&(a.head.text=h>>8&1),512&a.flags&&4&a.wrap&&(A[0]=255&h,A[1]=h>>>8&255,a.check=N(a.check,A,2,0)),h=0,d=0,a.mode=16182;case 16182:for(;d<32;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}a.head&&(a.head.time=h),512&a.flags&&4&a.wrap&&(A[0]=255&h,A[1]=h>>>8&255,A[2]=h>>>16&255,A[3]=h>>>24&255,a.check=N(a.check,A,4,0)),h=0,d=0,a.mode=16183;case 16183:for(;d<16;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}a.head&&(a.head.xflags=255&h,a.head.os=h>>8),512&a.flags&&4&a.wrap&&(A[0]=255&h,A[1]=h>>>8&255,a.check=N(a.check,A,2,0)),h=0,d=0,a.mode=16184;case 16184:if(1024&a.flags){for(;d<16;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}a.length=h,a.head&&(a.head.extra_len=h),512&a.flags&&4&a.wrap&&(A[0]=255&h,A[1]=h>>>8&255,a.check=N(a.check,A,2,0)),h=0,d=0}else a.head&&(a.head.extra=null);a.mode=16185;case 16185:if(1024&a.flags&&(c=a.length,c>o&&(c=o),c&&(a.head&&(y=a.head.extra_len-a.length,a.head.extra||(a.head.extra=new Uint8Array(a.head.extra_len)),a.head.extra.set(i.subarray(s,s+c),y)),512&a.flags&&4&a.wrap&&(a.check=N(a.check,i,c,s)),o-=c,s+=c,a.length-=c),a.length))break t;a.length=0,a.mode=16186;case 16186:if(2048&a.flags){if(0===o)break t;c=0;do{y=i[s+c++],a.head&&y&&a.length<65536&&(a.head.name+=String.fromCharCode(y))}while(y&&c<o);if(512&a.flags&&4&a.wrap&&(a.check=N(a.check,i,c,s)),o-=c,s+=c,y)break t}else a.head&&(a.head.name=null);a.length=0,a.mode=16187;case 16187:if(4096&a.flags){if(0===o)break t;c=0;do{y=i[s+c++],a.head&&y&&a.length<65536&&(a.head.comment+=String.fromCharCode(y))}while(y&&c<o);if(512&a.flags&&4&a.wrap&&(a.check=N(a.check,i,c,s)),o-=c,s+=c,y)break t}else a.head&&(a.head.comment=null);a.mode=16188;case 16188:if(512&a.flags){for(;d<16;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(4&a.wrap&&h!==(65535&a.check)){t.msg="header crc mismatch",a.mode=me;break}h=0,d=0}a.head&&(a.head.hcrc=a.flags>>9&1,a.head.done=!0),t.adler=a.check=0,a.mode=16191;break;case 16189:for(;d<32;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}t.adler=a.check=be(h),h=0,d=0,a.mode=16190;case 16190:if(0===a.havedict)return t.next_out=r,t.avail_out=l,t.next_in=s,t.avail_in=o,a.hold=h,a.bits=d,de;t.adler=a.check=1,a.mode=16191;case 16191:if(e===re||e===oe)break t;case 16192:if(a.last){h>>>=7&d,d-=7&d,a.mode=16206;break}for(;d<3;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}switch(a.last=1&h,h>>>=1,d-=1,3&h){case 0:a.mode=16193;break;case 1:if(Re(a),a.mode=16199,e===oe){h>>>=2,d-=2;break t}break;case 2:a.mode=16196;break;case 3:t.msg="invalid block type",a.mode=me}h>>>=2,d-=2;break;case 16193:for(h>>>=7&d,d-=7&d;d<32;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if((65535&h)!=(h>>>16^65535)){t.msg="invalid stored block lengths",a.mode=me;break}if(a.length=65535&h,h=0,d=0,a.mode=16194,e===oe)break t;case 16194:a.mode=16195;case 16195:if(c=a.length,c){if(c>o&&(c=o),c>l&&(c=l),0===c)break t;n.set(i.subarray(s,s+c),r),o-=c,s+=c,l-=c,r+=c,a.length-=c;break}a.mode=16191;break;case 16196:for(;d<14;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(a.nlen=257+(31&h),h>>>=5,d-=5,a.ndist=1+(31&h),h>>>=5,d-=5,a.ncode=4+(15&h),h>>>=4,d-=4,a.nlen>286||a.ndist>30){t.msg="too many length or distance symbols",a.mode=me;break}a.have=0,a.mode=16197;case 16197:for(;a.have<a.ncode;){for(;d<3;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}a.lens[Z[a.have++]]=7&h,h>>>=3,d-=3}for(;a.have<19;)a.lens[Z[a.have++]]=0;if(a.lencode=a.lendyn,a.lenbits=7,E={bits:a.lenbits},x=ne(0,a.lens,0,19,a.lencode,0,a.work,E),a.lenbits=E.bits,x){t.msg="invalid code lengths set",a.mode=me;break}a.have=0,a.mode=16198;case 16198:for(;a.have<a.nlen+a.ndist;){for(;z=a.lencode[h&(1<<a.lenbits)-1],m=z>>>24,b=z>>>16&255,g=65535&z,!(m<=d);){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(g<16)h>>>=m,d-=m,a.lens[a.have++]=g;else{if(16===g){for(R=m+2;d<R;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(h>>>=m,d-=m,0===a.have){t.msg="invalid bit length repeat",a.mode=me;break}y=a.lens[a.have-1],c=3+(3&h),h>>>=2,d-=2}else if(17===g){for(R=m+3;d<R;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}h>>>=m,d-=m,y=0,c=3+(7&h),h>>>=3,d-=3}else{for(R=m+7;d<R;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}h>>>=m,d-=m,y=0,c=11+(127&h),h>>>=7,d-=7}if(a.have+c>a.nlen+a.ndist){t.msg="invalid bit length repeat",a.mode=me;break}for(;c--;)a.lens[a.have++]=y}}if(a.mode===me)break;if(0===a.lens[256]){t.msg="invalid code -- missing end-of-block",a.mode=me;break}if(a.lenbits=9,E={bits:a.lenbits},x=ne(1,a.lens,0,a.nlen,a.lencode,0,a.work,E),a.lenbits=E.bits,x){t.msg="invalid literal/lengths set",a.mode=me;break}if(a.distbits=6,a.distcode=a.distdyn,E={bits:a.distbits},x=ne(2,a.lens,a.nlen,a.ndist,a.distcode,0,a.work,E),a.distbits=E.bits,x){t.msg="invalid distances set",a.mode=me;break}if(a.mode=16199,e===oe)break t;case 16199:a.mode=16200;case 16200:if(o>=6&&l>=258){t.next_out=r,t.avail_out=l,t.next_in=s,t.avail_in=o,a.hold=h,a.bits=d,$t(t,f),r=t.next_out,n=t.output,l=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,h=a.hold,d=a.bits,16191===a.mode&&(a.back=-1);break}for(a.back=0;z=a.lencode[h&(1<<a.lenbits)-1],m=z>>>24,b=z>>>16&255,g=65535&z,!(m<=d);){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(b&&0==(240&b)){for(p=m,k=b,v=g;z=a.lencode[v+((h&(1<<p+k)-1)>>p)],m=z>>>24,b=z>>>16&255,g=65535&z,!(p+m<=d);){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}h>>>=p,d-=p,a.back+=p}if(h>>>=m,d-=m,a.back+=m,a.length=g,0===b){a.mode=16205;break}if(32&b){a.back=-1,a.mode=16191;break}if(64&b){t.msg="invalid literal/length code",a.mode=me;break}a.extra=15&b,a.mode=16201;case 16201:if(a.extra){for(R=a.extra;d<R;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}a.length+=h&(1<<a.extra)-1,h>>>=a.extra,d-=a.extra,a.back+=a.extra}a.was=a.length,a.mode=16202;case 16202:for(;z=a.distcode[h&(1<<a.distbits)-1],m=z>>>24,b=z>>>16&255,g=65535&z,!(m<=d);){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(0==(240&b)){for(p=m,k=b,v=g;z=a.distcode[v+((h&(1<<p+k)-1)>>p)],m=z>>>24,b=z>>>16&255,g=65535&z,!(p+m<=d);){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}h>>>=p,d-=p,a.back+=p}if(h>>>=m,d-=m,a.back+=m,64&b){t.msg="invalid distance code",a.mode=me;break}a.offset=g,a.extra=15&b,a.mode=16203;case 16203:if(a.extra){for(R=a.extra;d<R;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}a.offset+=h&(1<<a.extra)-1,h>>>=a.extra,d-=a.extra,a.back+=a.extra}if(a.offset>a.dmax){t.msg="invalid distance too far back",a.mode=me;break}a.mode=16204;case 16204:if(0===l)break t;if(c=f-l,a.offset>c){if(c=a.offset-c,c>a.whave&&a.sane){t.msg="invalid distance too far back",a.mode=me;break}c>a.wnext?(c-=a.wnext,u=a.wsize-c):u=a.wnext-c,c>a.length&&(c=a.length),w=a.window}else w=n,u=r-a.offset,c=a.length;c>l&&(c=l),l-=c,a.length-=c;do{n[r++]=w[u++]}while(--c);0===a.length&&(a.mode=16200);break;case 16205:if(0===l)break t;n[r++]=a.length,l--,a.mode=16200;break;case 16206:if(a.wrap){for(;d<32;){if(0===o)break t;o--,h|=i[s++]<<d,d+=8}if(f-=l,t.total_out+=f,a.total+=f,4&a.wrap&&f&&(t.adler=a.check=a.flags?N(a.check,n,f,r-f):F(a.check,n,f,r-f)),f=l,4&a.wrap&&(a.flags?h:be(h))!==a.check){t.msg="incorrect data check",a.mode=me;break}h=0,d=0}a.mode=16207;case 16207:if(a.wrap&&a.flags){for(;d<32;){if(0===o)break t;o--,h+=i[s++]<<d,d+=8}if(4&a.wrap&&h!==(4294967295&a.total)){t.msg="incorrect length check",a.mode=me;break}h=0,d=0}a.mode=16208;case 16208:x=he;break t;case me:x=fe;break t;case 16210:return ce;default:return _e}return t.next_out=r,t.avail_out=l,t.next_in=s,t.avail_in=o,a.hold=h,a.bits=d,(a.wsize||f!==t.avail_out&&a.mode<me&&(a.mode<16206||e!==se))&&Ze(t,t.output,t.next_out,f-t.avail_out),_-=t.avail_in,f-=t.avail_out,t.total_in+=_,t.total_out+=f,a.total+=f,4&a.wrap&&f&&(t.adler=a.check=a.flags?N(a.check,n,f,t.next_out-f):F(a.check,n,f,t.next_out-f)),t.data_type=a.bits+(a.last?64:0)+(16191===a.mode?128:0)+(16199===a.mode||16194===a.mode?256:0),(0===_&&0===f||e===se)&&x===le&&(x=ue),x},inflateEnd:t=>{if(pe(t))return _e;let e=t.state;return e.window&&(e.window=null),t.state=null,le},inflateGetHeader:(t,e)=>{if(pe(t))return _e;const a=t.state;return 0==(2&a.wrap)?_e:(a.head=e,e.done=!1,le)},inflateSetDictionary:(t,e)=>{const a=e.length;let i,n,s;return pe(t)?_e:(i=t.state,0!==i.wrap&&16190!==i.mode?_e:16190===i.mode&&(n=1,n=F(n,e,a,0),n!==i.check)?fe:(s=Ze(t,e,a,a),s?(i.mode=16210,ce):(i.havedict=1,le)))},inflateInfo:"pako inflate (from Nodeca project)"};var Se=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1};const De=Object.prototype.toString,{Z_NO_FLUSH:Te,Z_FINISH:Oe,Z_OK:Fe,Z_STREAM_END:Le,Z_NEED_DICT:Ne,Z_STREAM_ERROR:Ie,Z_DATA_ERROR:Be,Z_MEM_ERROR:Ce}=B;function He(t){this.options=Tt({chunkSize:65536,windowBits:15,to:""},t||{});const e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Ct,this.strm.avail_out=0;let a=Ue.inflateInit2(this.strm,e.windowBits);if(a!==Fe)throw new Error(I[a]);if(this.header=new Se,Ue.inflateGetHeader(this.strm,this.header),e.dictionary&&("string"==typeof e.dictionary?e.dictionary=Nt(e.dictionary):"[object ArrayBuffer]"===De.call(e.dictionary)&&(e.dictionary=new Uint8Array(e.dictionary)),e.raw&&(a=Ue.inflateSetDictionary(this.strm,e.dictionary),a!==Fe)))throw new Error(I[a])}He.prototype.push=function(t,e){const a=this.strm,i=this.options.chunkSize,n=this.options.dictionary;let s,r,o;if(this.ended)return!1;for(r=e===~~e?e:!0===e?Oe:Te,"[object ArrayBuffer]"===De.call(t)?a.input=new Uint8Array(t):a.input=t,a.next_in=0,a.avail_in=a.input.length;;){for(0===a.avail_out&&(a.output=new Uint8Array(i),a.next_out=0,a.avail_out=i),s=Ue.inflate(a,r),s===Ne&&n&&(s=Ue.inflateSetDictionary(a,n),s===Fe?s=Ue.inflate(a,r):s===Be&&(s=Ne));a.avail_in>0&&s===Le&&a.state.wrap>0&&0!==t[a.next_in];)Ue.inflateReset(a),s=Ue.inflate(a,r);switch(s){case Ie:case Be:case Ne:case Ce:return this.onEnd(s),this.ended=!0,!1}if(o=a.avail_out,a.next_out&&(0===a.avail_out||s===Le))if("string"===this.options.to){let t=Bt(a.output,a.next_out),e=a.next_out-t,n=It(a.output,t);a.next_out=e,a.avail_out=i-e,e&&a.output.set(a.output.subarray(t,t+e),0),this.onData(n)}else this.onData(a.output.length===a.next_out?a.output:a.output.subarray(0,a.next_out));if(s!==Fe||0!==o){if(s===Le)return s=Ue.inflateEnd(this.strm),this.onEnd(s),this.ended=!0,!0;if(0===a.avail_in)break}}return!0},He.prototype.onData=function(t){this.chunks.push(t)},He.prototype.onEnd=function(t){t===Fe&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=Ot(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg};const{Deflate:Me,deflate:je,deflateRaw:Ke,gzip:Pe}=Vt;var Ye=Me,Ge=je,Xe=B;const We=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error("Adding invalid event");const e=this._hasEvents?",":"";this.deflate.push(e+t,Xe.Z_SYNC_FLUSH),this._hasEvents=!0}finish(){if(this.deflate.push("]",Xe.Z_FINISH),this.deflate.err)throw this.deflate.err;const t=this.deflate.result;return this._init(),t}_init(){this._hasEvents=!1,this.deflate=new Ye,this.deflate.push("[",Xe.Z_NO_FLUSH)}},qe={clear:()=>{We.clear()},addEvent:t=>We.addEvent(t),finish:()=>We.finish(),compress:t=>function(t){return Ge(t)}(t)};addEventListener("message",(function(t){const e=t.data.method,a=t.data.id,i=t.data.arg;if(e in qe&&"function"==typeof qe[e])try{const t=qe[e](i);postMessage({id:a,method:e,success:!0,response:t})}catch(t){postMessage({id:a,method:e,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:"init",success:!0,response:void 0});']); return URL.createObjectURL(t) }(), e = new Worker(t); return new cr(e) } catch (t) { } return new sr } function hr(t, e, n = +new Date) { return null === t || void 0 === e || e < 0 || 0 !== e && t + e <= n } function lr(t, e, n = +new Date) { return hr(t.started, e.maxSessionLife, n) || hr(t.lastActivity, e.sessionIdle, n) } function dr(t) { if ("sessionStorage" in vn) try { vn.sessionStorage.setItem(kn, JSON.stringify(t)) } catch (t) { } } function fr(t) { return void 0 !== t && Math.random() < t } function pr(t) { const e = Date.now(); return { id: t.id || ct(), started: t.started || e, lastActivity: t.lastActivity || e, segmentId: t.segmentId || 0, sampled: t.sampled } } function mr({ sessionSampleRate: t, errorSampleRate: e, stickySession: n = !1 }) { const i = function (t, e) { return fr(t) ? "session" : !!fr(e) && "error" }(t, e), r = pr({ sampled: i }); return n && dr(r), r } function _r({ timeouts: t, currentSession: e, stickySession: n, sessionSampleRate: i, errorSampleRate: r }) { const s = e || n && function () { if (!("sessionStorage" in vn)) return null; try { const t = vn.sessionStorage.getItem(kn); return t ? pr(JSON.parse(t)) : null } catch (t) { return null } }(); if (s) { if (!lr(s, t)) return { type: "saved", session: s }; if ("error" === s.sampled) { return { type: "new", session: pr({ sampled: !1 }) } } } return { type: "new", session: mr({ stickySession: n, sessionSampleRate: i, errorSampleRate: r }) } } async function yr(t, e, n) { if (!t.eventBuffer) return null; if (t.isPaused()) return null; const i = e.timestamp > 9999999999 ? e.timestamp : 1e3 * e.timestamp; if (i + t.timeouts.sessionIdle < Date.now()) return null; const r = t.getContext().earliestEvent; t.session && 0 === t.session.segmentId && (!r || i < r) && (t.getContext().earliestEvent = i); try { return await t.eventBuffer.addEvent(e, n) } catch (e) { t.stop("addEvent"); const n = se().getClient(); n && n.recordDroppedEvent("internal_sdk_error", "replay") } } function gr(t) { return !t.type } function br(t) { return "transaction" === t.type } function wr(t) { const e = function () { const t = se().getClient(); if (!t) return !1; const e = t.getTransport(); if (!e) return !1; return e.send.__sentry__baseTransport__ || !1 }(); return (n, i) => { if (!gr(n) && !br(n)) return; const r = i && i.statusCode; e && (!r || r < 200 || r >= 300) || (br(n) && n.contexts && n.contexts.trace && n.contexts.trace.trace_id ? t.getContext().traceIds.add(n.contexts.trace.trace_id) : gr(n) && (n.event_id && t.getContext().errorIds.add(n.event_id), "error" === t.recordingMode && n.exception && n.message !== Sn && setTimeout((async () => { await t.flushImmediate(), t.stopRecording() && (t.recordingMode = "session", t.startRecording()) })))) } } var vr; function kr(t) { return { timestamp: Date.now() / 1e3, type: "default", ...t } } function Sr(t, e) { "sentry.transaction" !== e.category && (["ui.click", "ui.input"].includes(e.category) ? t.triggerUserActivity() : t.checkAndHandleExpiredSession(), t.addUpdate((() => (yr(t, { type: Yn.Custom, timestamp: 1e3 * (e.timestamp || 0), data: { tag: "breadcrumb", payload: mt(e, 10, 1e3) } }), "console" === e.category)))) } !function (t) { t[t.Document = 0] = "Document", t[t.DocumentType = 1] = "DocumentType", t[t.Element = 2] = "Element", t[t.Text = 3] = "Text", t[t.CDATA = 4] = "CDATA", t[t.Comment = 5] = "Comment" }(vr || (vr = {})); const xr = new Set(["id", "class", "aria-label", "role", "name", "alt", "title", "data-test-id", "data-testid"]); function Tr(t) { const e = {}; for (const n in t) if (xr.has(n)) { let i = n; "data-testid" !== n && "data-test-id" !== n || (i = "testId"), e[i] = t[n] } return e } const Er = t => e => { if (!t.isEnabled()) return; const n = function (t) { let e, n; try { n = function (t) { if (e = t.event, e.target) return t.event.target; var e; return t.event }(t), e = g(n) } catch (t) { e = "<unknown>" } const i = n && "__sn" in n && n.__sn.type === vr.Element ? n.__sn : null; return kr({ category: `ui.${t.name}`, message: e, data: i ? { nodeId: i.id, node: { id: i.id, tagName: i.tagName, textContent: n ? Array.from(n.childNodes).map((t => "__sn" in t && t.__sn.type === vr.Text && t.__sn.textContent)).filter(Boolean).map((t => t.trim())).join("") : "", attributes: Tr(i.attributes) } } : {} }) }(e); n && Sr(t, n) }; function Ir(t, e) { return e.map((({ type: e, start: n, end: i, name: r, data: s }) => yr(t, { type: Yn.Custom, timestamp: n, data: { tag: "performanceSpan", payload: { op: e, description: r, startTimestamp: n, endTimestamp: i, data: s } } }))) } function Ar(t) { return e => { if (!t.isEnabled()) return; const n = function (t) { const { from: e, to: n } = t, i = Date.now() / 1e3; return { type: "navigation.push", start: i, end: i, name: n, data: { previous: e } } }(e); null !== n && (t.getContext().urls.push(n.name), t.triggerUserActivity(), t.addUpdate((() => (Ir(t, [n]), !1)))) } } function Cr(t, e) { return function (t) { const e = se().getClient(), n = e && e.getDsn(); return !!n && t.includes(n.host) }(e) } function Or(t, e) { t.isEnabled() && null !== e && (Cr(0, e.name) || t.addUpdate((() => (Ir(t, [e]), !0)))) } const Rr = 10, zr = 11, Dr = 12, Lr = 13, Mr = 14, $r = 15, Nr = 20, Fr = 21, jr = 22, Ur = 23, Br = ["true", "false", "null"]; function Hr(t, e) { if (!e.length) return t; let n = t; const i = e.length - 1; n = function (t, e) { switch (e) { case Rr: return `${t}"~~":"~~"`; case 11: return `${t}:"~~"`; case 12: return `${t}~~":"~~"`; case Lr: return function (t) { const e = t.lastIndexOf(":"), n = t.slice(e + 1); if (Br.includes(n.trim())) return `${t},"~~":"~~"`; return `${t.slice(0, e + 1)}"~~"` }(t); case 14: return `${t}~~"`; case $r: return `${t},"~~":"~~"`; case Nr: return `${t}"~~"`; case Fr: return function (t) { const e = function (t) { for (let e = t.length - 1; e >= 0; e--) { const n = t[e]; if ("," === n || "[" === n) return e } return -1 }(t); if (e > -1) { const n = t.slice(e + 1); return Br.includes(n.trim()) ? `${t},"~~"` : `${t.slice(0, e + 1)}"~~"` } return t }(t); case 22: return `${t}~~"`; case Ur: return `${t},"~~"` }return t }(n, e[i]); for (let t = i; t >= 0; t--) { switch (e[t]) { case Rr: n = `${n}}`; break; case Nr: n = `${n}]` } } return n } function Zr(t, e, n) { const i = t[t.length - 1], r = e[n]; if (!/\s/.test(r)) if ('"' !== r || Pr(e, n)) switch (r) { case "{": !function (t, e) { if (!e) return void t.push(Rr); if (e === Lr) return void t.push(Rr); e === Fr && t.push(Rr); if (e === Nr) t.push(Rr) }(t, i); break; case "[": !function (t, e) { if (!e) return t.push(Nr), void t.push(Fr); if (e === Lr) return t.push(Nr), void t.push(Fr); e === Fr && (t.push(Nr), t.push(Fr)); if (e === Nr) t.push(Nr), t.push(Fr) }(t, i); break; case ":": !function (t, e) { e === zr && (t.pop(), t.push(Lr)) }(t, i); break; case ",": !function (t, e) { if (e === Lr) return void t.pop(); if (e === $r) return t.pop(), void t.pop(); if (e === Fr) return; if (e === Ur) t.pop() }(t, i); break; case "}": !function (t, e) { e === Rr && t.pop(); e === Lr && (t.pop(), t.pop()); e === $r && (t.pop(), t.pop(), t.pop()); t[t.length - 1] === Lr && t.push($r); t[t.length - 1] === Fr && t.push(Ur) }(t, i); break; case "]": !function (t, e) { e === Nr && t.pop(); e === Fr && (t.pop(), t.pop()); e === Ur && (t.pop(), t.pop(), t.pop()); t[t.length - 1] === Lr && t.push($r); t[t.length - 1] === Fr && t.push(Ur) }(t, i) } else !function (t, e) { if (e === Mr) return t.pop(), void t.push($r); if (e === jr) return t.pop(), void t.push(Ur); if (e === Lr) return void t.push(Mr); if (e === Fr) return void t.push(jr); if (e === Rr) return void t.push(Dr); if (e === Dr) t.pop(), t.push(11) }(t, i) } function Pr(t, e) { return "\\" === t[e - 1] && !Pr(t, e - 1) } function qr(t) { return Hr(t, function (t) { const e = []; for (let n = 0; n < t.length; n++)Zr(e, t, n); return e }(t)) } function Wr(t, e) { if (t) try { if ("string" == typeof t) return e.encode(t).length; if (t instanceof URLSearchParams) return e.encode(t.toString()).length; if (t instanceof FormData) { const n = Vr(t); return e.encode(n).length } if (t instanceof Blob) return t.size; if (t instanceof ArrayBuffer) return t.byteLength } catch (t) { } } function Xr(t) { if (!t) return; const e = parseInt(t, 10); return isNaN(e) ? void 0 : e } function Gr(t) { return "string" == typeof t ? t : t instanceof URLSearchParams ? t.toString() : t instanceof FormData ? Vr(t) : void 0 } function Jr(t, e) { if (!e) return null; const { startTimestamp: n, endTimestamp: i, url: r, method: s, statusCode: a, request: o, response: c } = e; return { type: t, start: n / 1e3, end: i / 1e3, name: r, data: F({ method: s, statusCode: a, request: o, response: c }) } } function Kr(t, e, n) { if (!e && 0 === Object.keys(t).length) return; if (!e) return { headers: t }; if (!n) return { headers: t, size: e }; const i = { headers: t, size: e }, { body: r, warnings: s } = function (t) { if (!t || "string" != typeof t) return { body: t, warnings: [] }; const e = t.length > xn; if (function (t) { const e = t[0], n = t[t.length - 1]; return "[" === e && "]" === n || "{" === e && "}" === n }(t)) try { const n = e ? qr(t.slice(0, xn)) : t; return { body: JSON.parse(n), warnings: e ? ["JSON_TRUNCATED"] : [] } } catch (e) { return { body: t, warnings: ["INVALID_JSON"] } } return { body: e ? `${t.slice(0, xn)}…` : t, warnings: e ? ["TEXT_TRUNCATED"] : [] } }(n); return i.body = r, s.length > 0 && (i.re = { warnings: s }), i } function Yr(t, e) { return Object.keys(t).reduce(((n, i) => { const r = i.toLowerCase(); return e.includes(r) && t[i] && (n[r] = t[i]), n }), {}) } function Vr(t) { return new URLSearchParams(t).toString() } async function Qr(t, e, n) { try { const i = await async function (t, e, n) { const { startTimestamp: i, endTimestamp: r } = e, { url: s, method: a, status_code: o, request_body_size: c, response_body_size: u } = t.data, h = function ({ captureBodies: t, requestHeaders: e }, n, i) { const r = function (t, e) { if (1 === t.length && "string" != typeof t[0]) return ns(t[0], e); if (2 === t.length) return ns(t[1], e); return {} }(n, e); if (!t) return Kr(r, i, void 0); const s = Gr(ts(n)); return Kr(r, i, s) }(n, e.input, c), l = await async function ({ captureBodies: t, textEncoder: e, responseHeaders: n }, i, r) { const s = es(i.headers, n); if (!t && void 0 !== r) return Kr(s, r, void 0); try { const n = i.clone(), a = await async function (t) { try { return await t.text() } catch (t) { return } }(n), o = a && a.length && void 0 === r ? Wr(a, e) : r; return Kr(s, o, t ? a : void 0) } catch (t) { return Kr(s, r, void 0) } }(n, e.response, u); return { startTimestamp: i, endTimestamp: r, url: s, method: a, statusCode: o || 0, request: h, response: l } }(t, e, n), r = Jr("resource.fetch", i); Or(n.replay, r) } catch (t) { } } function ts(t = []) { if (2 === t.length && "object" == typeof t[1]) return t[1].body } function es(t, e) { const n = {}; return e.forEach((e => { t.get(e) && (n[e] = t.get(e)) })), n } function ns(t, e) { if (!t) return {}; const n = t.headers; return n ? n instanceof Headers ? es(n, e) : Array.isArray(n) ? {} : Yr(n, e) : {} } async function is(t, e, n) { try { const i = function (t, e, n) { const { startTimestamp: i, endTimestamp: r, input: s, xhr: a } = e, { url: o, method: c, status_code: u, request_body_size: h, response_body_size: l } = t.data, d = a.__sentry_xhr_v2__, f = d ? Yr(d.request_headers, n.requestHeaders) : {}, p = Yr(function (t) { const e = t.getAllResponseHeaders(); if (!e) return {}; return e.split("\r\n").reduce(((t, e) => { const [n, i] = e.split(": "); return t[n.toLowerCase()] = i, t }), {}) }(a), n.responseHeaders); if (!o) return null; const m = Kr(f, h, n.captureBodies ? Gr(s) : void 0), _ = Kr(p, l, n.captureBodies ? e.xhr.responseText : void 0); return { startTimestamp: i, endTimestamp: r, url: o, method: c, statusCode: u || 0, request: m, response: _ } }(t, e, n), r = Jr("resource.xhr", i); Or(n.replay, r) } catch (t) { } } function rs(t) { const e = se().getClient(); try { const n = { replay: t, textEncoder: new TextEncoder, ...t.getExperimentalOptions().network }; e && e.on ? e.on("beforeAddBreadcrumb", ((t, e) => function (t, e, n) { if (!e.data) return; try { (function (t) { return "xhr" === t.category })(e) && function (t) { return t && t.xhr }(n) && (!function (t, e, n) { const { xhr: i, input: r } = e, s = Wr(r, n.textEncoder), a = i.getResponseHeader("content-length") ? Xr(i.getResponseHeader("content-length")) : Wr(i.response, n.textEncoder); void 0 !== s && (t.data.request_body_size = s), void 0 !== a && (t.data.response_body_size = a) }(e, n, t), is(e, n, t)), function (t) { return "fetch" === t.category }(e) && function (t) { return t && t.response }(n) && (!function (t, e, n) { const { input: i, response: r } = e, s = Wr(ts(i), n.textEncoder), a = r ? Xr(r.headers.get("content-length")) : void 0; void 0 !== s && (t.data.request_body_size = s), void 0 !== a && (t.data.response_body_size = a) }(e, n, t), Qr(e, n, t)) } catch (t) { } }(n, t, e))) : (V("fetch", function (t) { return e => { if (!t.isEnabled()) return; const n = function (t) { const { startTimestamp: e, endTimestamp: n, fetchData: i, response: r } = t; if (!n) return null; const { method: s, url: a } = i; return { type: "resource.fetch", start: e / 1e3, end: n / 1e3, name: a, data: { method: s, statusCode: r && r.status } } }(e); Or(t, n) } }(t)), V("xhr", function (t) { return e => { if (!t.isEnabled()) return; const n = function (t) { const { startTimestamp: e, endTimestamp: n, xhr: i } = t, r = i.__sentry_xhr_v2__; if (!e || !n || !r) return null; const { method: s, url: a, status_code: o } = r; return void 0 === a ? null : { type: "resource.xhr", name: a, start: e / 1e3, end: n / 1e3, data: { method: s, statusCode: o } } }(e); Or(t, n) } }(t))) } catch (t) { } } let ss = null; const as = t => e => { if (!t.isEnabled()) return; const n = function (t) { const e = t.getLastBreadcrumb && t.getLastBreadcrumb(); if (ss === e || !e) return null; if (ss = e, e.category && (["fetch", "xhr", "sentry.event", "sentry.transaction"].includes(e.category) || e.category.startsWith("ui."))) return null; return kr(e) }(e); n && Sr(t, n) }; function os(t) { const e = se().getScope(), n = se().getClient(); e && e.addScopeListener(as(t)), V("dom", Er(t)), V("history", Ar(t)), rs(t), te(function (t, e = !1) { const n = e ? wr(t) : void 0; return (e, i) => function (t) { return "replay_event" === t.type }(e) ? (delete e.breadcrumbs, e) : gr(e) || br(e) ? function (t, e) { return !(t.type || !t.exception || !t.exception.values || !t.exception.values.length) && (!(!e.originalException || !e.originalException.__rrweb__) || t.exception.values.some((t => !!(t.stacktrace && t.stacktrace.frames && t.stacktrace.frames.length) && t.stacktrace.frames.some((t => t.filename && t.filename.includes("/rrweb/src/")))))) }(e, i) && !t.getOptions()._experiments.captureExceptions ? null : ((gr(e) || br(e) && "session" === t.recordingMode) && (e.tags = { ...e.tags, replayId: t.getSessionId() }), n && n(e, { statusCode: 200 }), e) : e }(t, !cs(n))), cs(n) && (n.on("afterSendEvent", wr(t)), n.on("createDsc", (e => { const n = t.getSessionId(); n && (e.replay_id = n) }))) } function cs(t) { return !(!t || !t.on) } function us(t) { const { jsHeapSizeLimit: e, totalJSHeapSize: n, usedJSHeapSize: i } = t, r = Date.now() / 1e3; return { type: "memory", name: "memory", start: r, end: r, data: { memory: { jsHeapSizeLimit: e, totalJSHeapSize: n, usedJSHeapSize: i } } } } const hs = { resource: function (t) { const { entryType: e, initiatorType: n, name: i, responseEnd: r, startTime: s, decodedBodySize: a, encodedBodySize: o, responseStatus: c, transferSize: u } = t; if (["fetch", "xmlhttprequest"].includes(n)) return null; return { type: `${e}.${n}`, start: ds(s), end: ds(r), name: i, data: { size: u, statusCode: c, decodedBodySize: a, encodedBodySize: o } } }, paint: function (t) { const { duration: e, entryType: n, name: i, startTime: r } = t, s = ds(r); return { type: n, name: i, start: s, end: s + e, data: void 0 } }, navigation: function (t) { const { entryType: e, name: n, decodedBodySize: i, duration: r, domComplete: s, encodedBodySize: a, domContentLoadedEventStart: o, domContentLoadedEventEnd: c, domInteractive: u, loadEventStart: h, loadEventEnd: l, redirectCount: d, startTime: f, transferSize: p, type: m } = t; if (0 === r) return null; return { type: `${e}.${m}`, start: ds(f), end: ds(s), name: n, data: { size: p, decodedBodySize: i, encodedBodySize: a, duration: r, domInteractive: u, domContentLoadedEventStart: o, domContentLoadedEventEnd: c, loadEventStart: h, loadEventEnd: l, domComplete: s, redirectCount: d } } }, "largest-contentful-paint": function (t) { const { entryType: e, startTime: n, size: i } = t; let r = 0; if (vn.performance) { const t = vn.performance.getEntriesByType("navigation")[0]; r = t && t.activationStart || 0 } const s = Math.max(n - r, 0), a = ds(r) + s / 1e3; return { type: e, name: e, start: a, end: a, data: { value: s, size: i, nodeId: er.mirror.getId(t.element) } } } }; function ls(t) { return void 0 === hs[t.entryType] ? null : hs[t.entryType](t) } function ds(t) { return ((Rt || vn.performance.timeOrigin) + t) / 1e3 } function fs(t) { let e = !1; return (n, i) => { if (!t.checkAndHandleExpiredSession()) return; const r = i || !e; e = !0, t.addUpdate((() => { if ("error" === t.recordingMode && r && t.setInitialState(), yr(t, n, r), !r) return !1; if (t.session && t.session.previousSessionId) return !0; if ("error" === t.recordingMode && t.session) { const { earliestEvent: e } = t.getContext(); e && (t.session.started = e, t.getOptions().stickySession && dr(t.session)) } return "session" === t.recordingMode && t.flushImmediate(), !0 })) } } async function ps({ recordingData: t, replayId: e, segmentId: n, eventContext: i, timestamp: r, session: s, options: a }) { const o = function ({ recordingData: t, headers: e }) { let n; const i = `${JSON.stringify(e)}\n`; if ("string" == typeof t) n = `${i}${t}`; else { const e = (new TextEncoder).encode(i); n = new Uint8Array(e.length + t.length), n.set(e), n.set(t, e.length) } return n }({ recordingData: t, headers: { segment_id: n } }), { urls: c, errorIds: u, traceIds: h, initialTimestamp: l } = i, d = se(), f = d.getClient(), p = d.getScope(), m = f && f.getTransport(), _ = f && f.getDsn(); if (!(f && p && m && _ && s.sampled)) return; const y = { type: "replay_event", replay_start_timestamp: l / 1e3, timestamp: r / 1e3, error_ids: u, trace_ids: h, urls: c, replay_id: e, segment_id: n, replay_type: s.sampled }, g = await async function ({ client: t, scope: e, replayId: n, event: i }) { const r = "object" != typeof t._integrations || null === t._integrations || Array.isArray(t._integrations) ? void 0 : Object.keys(t._integrations), s = await ze(t.getOptions(), i, { event_id: n, integrations: r }, e); if (!s) return null; s.platform = s.platform || "javascript"; const a = t.getSdkMetadata && t.getSdkMetadata(), { name: o, version: c } = a && a.sdk || {}; return s.sdk = { ...s.sdk, name: o || "sentry.javascript.unknown", version: c || "0.0.0" }, s }({ scope: p, client: f, replayId: e, event: y }); if (!g) return void f.recordDroppedEvent("event_processor", "replay", y); g.contexts = { ...g.contexts, replay: { ...g.contexts && g.contexts.replay, session_sample_rate: a.sessionSampleRate, error_sample_rate: a.errorSampleRate } }; const b = function (t, e, n, i) { return Dt(Ht(t, Bt(t), i, n), [[{ type: "replay_event" }, t], [{ type: "replay_recording", length: "string" == typeof e ? (new TextEncoder).encode(e).length : e.length }, e]]) }(g, o, _, f.getOptions().tunnel); let w; try { w = await m.send(b) } catch (t) { const e = new Error(Sn); try { e.cause = t } catch (t) { } throw e } if (!w) return w; if ("number" == typeof w.statusCode && (w.statusCode < 200 || w.statusCode >= 300)) throw new ms(w.statusCode); return w } class ms extends Error { constructor(t) { super(`Transport returned status code ${t}`) } } async function _s(t, e = { count: 0, interval: 5e3 }) { const { recordingData: n, options: i } = t; if (n.length) try { return await ps(t), !0 } catch (n) { if (n instanceof ms) throw n; if (xe("Replays", { se: e.count }), e.count >= 3) { const t = new Error("Unable to send Replay - max retries exceeded"); try { t.cause = n } catch (t) { } throw t } return e.interval *= ++e.count, await new Promise(((n, i) => { setTimeout((async () => { try { await _s(t, e), n(!0) } catch (t) { i(t) } }), e.interval) })) } } class ys { __init() { this.eventBuffer = null } __init2() { this.performanceEvents = [] } __init3() { this.recordingMode = "session" } __init4() { this.timeouts = { sessionIdle: 3e5, maxSessionLife: 36e5 } } __init5() { this.ae = null } __init6() { this.oe = null } __init7() { this.ce = Date.now() } __init8() { this.zt = !1 } __init9() { this.ue = !1 } __init10() { this.he = !1 } __init11() { this.le = null } __init12() { this.de = { errorIds: new Set, traceIds: new Set, urls: [], earliestEvent: null, initialTimestamp: Date.now(), initialUrl: "" } } constructor({ options: t, recordingOptions: e }) { ys.prototype.__init.call(this), ys.prototype.__init2.call(this), ys.prototype.__init3.call(this), ys.prototype.__init4.call(this), ys.prototype.__init5.call(this), ys.prototype.__init6.call(this), ys.prototype.__init7.call(this), ys.prototype.__init8.call(this), ys.prototype.__init9.call(this), ys.prototype.__init10.call(this), ys.prototype.__init11.call(this), ys.prototype.__init12.call(this), ys.prototype.__init13.call(this), ys.prototype.__init14.call(this), ys.prototype.__init15.call(this), ys.prototype.__init16.call(this), ys.prototype.__init17.call(this), this.fe = e, this.It = t, this.pe = function (t, e, n) { let i, r, s; const a = n && n.maxWait ? Math.max(n.maxWait, e) : 0; function o() { return c(), i = t(), i } function c() { void 0 !== r && clearTimeout(r), void 0 !== s && clearTimeout(s), r = s = void 0 } function u() { return r && clearTimeout(r), r = setTimeout(o, e), a && void 0 === s && (s = setTimeout(o, a)), i } return u.cancel = c, u.flush = function () { return void 0 !== r || void 0 !== s ? o() : i }, u }((() => this.me()), this.It.flushMinDelay, { maxWait: this.It.flushMaxDelay }), this._e = function (t) { const e = t._experiments.captureRequestHeaders || [], n = t._experiments.captureResponseHeaders || [], i = t._experiments.captureNetworkBodies || !1, r = ["content-length", "content-type", "accept"]; return { network: { captureBodies: i, requestHeaders: [...r, ...e.map((t => t.toLowerCase()))], responseHeaders: [...r, ...n.map((t => t.toLowerCase()))] } } }(t) } getContext() { return this.de } isEnabled() { return this.zt } isPaused() { return this.ue } getOptions() { return this.It } getExperimentalOptions() { return this._e } start() { this.setInitialState(), this.ye() && (this.session ? this.session.sampled && ("error" === this.session.sampled && (this.recordingMode = "error"), this.ge(), this.eventBuffer = ur({ useCompression: this.It.useCompression }), this.be(), this.zt = !0, this.startRecording()) : this.we(new Error("No session found"))) } startRecording() { try { this.le = er({ ...this.fe, ..."error" === this.recordingMode && { checkoutEveryNms: 6e4 }, emit: fs(this), onMutation: this.ve }) } catch (t) { this.we(t) } } stopRecording() { try { return !!this.le && (this.le(), this.le = void 0, !0) } catch (t) { return this.we(t), !1 } } stop(t) { if (this.zt) try { this.zt = !1, this.ke(), this.stopRecording(), this.eventBuffer && this.eventBuffer.destroy(), this.eventBuffer = null, this.pe.cancel() } catch (t) { this.we(t) } } pause() { this.ue = !0, this.stopRecording() } resume() { this.ye() && (this.ue = !1, this.startRecording()) } addUpdate(t) { const e = t(); "error" !== this.recordingMode && !0 !== e && this.pe() } triggerUserActivity() { if (this.Se(), this.le) this.checkAndHandleExpiredSession(), this.ge(); else { if (!this.ye()) return; this.resume() } } flushImmediate() { return this.pe(), this.pe.flush() } getSessionId() { return this.session && this.session.id } checkAndHandleExpiredSession() { const t = this.getSessionId(); if (this.ce && hr(this.ce, this.timeouts.sessionIdle) && this.session && "session" === this.session.sampled) return void this.pause(); if (!this.ye()) return; return t === this.getSessionId() || (this.xe(), !1) } setInitialState() { const t = `${vn.location.pathname}${vn.location.hash}${vn.location.search}`, e = `${vn.location.origin}${t}`; this.performanceEvents = [], this.Te(), this.de.initialUrl = e, this.de.initialTimestamp = Date.now(), this.de.urls.push(e) } we(t) { } ye() { const { type: t, session: e } = _r({ timeouts: this.timeouts, stickySession: Boolean(this.It.stickySession), currentSession: this.session, sessionSampleRate: this.It.sessionSampleRate, errorSampleRate: this.It.errorSampleRate }); "new" === t && this.setInitialState(); const n = this.getSessionId(); return e.id !== n && (e.previousSessionId = n), this.session = e, !!this.session.sampled || (this.stop("session unsampled"), !1) } be() { try { vn.document.addEventListener("visibilitychange", this.Ee), vn.addEventListener("blur", this.Ie), vn.addEventListener("focus", this.Ae), this.he || (os(this), this.he = !0) } catch (t) { this.we(t) } "PerformanceObserver" in vn && (this.ae = rr(this)) } ke() { try { vn.document.removeEventListener("visibilitychange", this.Ee), vn.removeEventListener("blur", this.Ie), vn.removeEventListener("focus", this.Ae), this.ae && (this.ae.disconnect(), this.ae = null) } catch (t) { this.we(t) } } __init13() { this.Ee = () => { "visible" === vn.document.visibilityState ? this.Ce() : this.Oe() } } __init14() { this.Ie = () => { const t = kr({ category: "ui.blur" }); this.Oe(t) } } __init15() { this.Ae = () => { const t = kr({ category: "ui.focus" }); this.Ce(t) } } Oe(t) { if (!this.session) return; const e = lr(this.session, this.timeouts); t && !e && this.Re(t), this.ze() } Ce(t) { if (!this.session) return; this.checkAndHandleExpiredSession() && t && this.Re(t) } xe(t = !0) { try { er.takeFullSnapshot(t) } catch (t) { this.we(t) } } Se(t = Date.now()) { this.ce = t } ge(t = Date.now()) { this.session && (this.session.lastActivity = t, this.De()) } Re(t) { this.addUpdate((() => { yr(this, { type: Yn.Custom, timestamp: t.timestamp || 0, data: { tag: "breadcrumb", payload: t } }) })) } Le() { const t = [...this.performanceEvents]; return this.performanceEvents = [], Promise.all(Ir(this, function (t) { return t.map(ls).filter(Boolean) }(t))) } ze() { "error" !== this.recordingMode && this.flushImmediate() } Te() { this.de.errorIds.clear(), this.de.traceIds.clear(), this.de.urls = [], this.de.earliestEvent = null } Me() { this.de.earliestEvent && this.de.earliestEvent < this.de.initialTimestamp && (this.de.initialTimestamp = this.de.earliestEvent); const t = { initialTimestamp: this.de.initialTimestamp, initialUrl: this.de.initialUrl, errorIds: Array.from(this.de.errorIds).filter(Boolean), traceIds: Array.from(this.de.traceIds).filter(Boolean), urls: this.de.urls }; return this.Te(), t } async $e() { if (this.session && this.eventBuffer && (await this.Le(), this.eventBuffer && this.eventBuffer.hasEvents && (await async function (t) { try { return Promise.all(Ir(t, [us(vn.performance.memory)])) } catch (t) { return [] } }(this), this.eventBuffer))) try { const t = await this.eventBuffer.finish(), e = this.session.id, n = this.Me(), i = this.session.segmentId++; this.De(), await _s({ replayId: e, recordingData: t, segmentId: i, eventContext: n, session: this.session, options: this.getOptions(), timestamp: Date.now() }) } catch (t) { this.we(t), this.stop("sendReplay"); const e = se().getClient(); e && e.recordDroppedEvent("send_error", "replay") } } __init16() { this.me = async () => { if (this.zt && this.checkAndHandleExpiredSession() && this.session) { if (this.pe.cancel(), !this.oe) return this.oe = this.$e(), await this.oe, void (this.oe = null); try { await this.oe } catch (t) { } finally { this.pe() } } } } De() { this.session && this.It.stickySession && dr(this.session) } __init17() { this.ve = t => { const e = t.length, n = this.It._experiments.mutationLimit || 0, i = n && e > n; if (e > (this.It._experiments.mutationBreadcrumbLimit || 1e3) || i) { const t = kr({ category: "replay.mutations", data: { count: e } }); this.Re(t) } return !i || (this.xe(!1), !1) } } } function gs(t, e, n, i) { const r = [...t, ..."string" == typeof i ? i.split(",") : [], ...e]; return void 0 !== n && ("string" == typeof n && r.push(`.${n}`), console.warn("[Replay] You are using a deprecated configuration item for privacy. Read the documentation on how to use the new privacy configuration.")), r.join(",") } function bs({ mask: t, unmask: e, block: n, unblock: i, ignore: r, blockClass: s, blockSelector: a, maskTextClass: o, maskTextSelector: c, ignoreClass: u }) { const h = gs(t, [".sentry-mask", "[data-sentry-mask]"], o, c), l = gs(e, [".sentry-unmask", "[data-sentry-unmask]"]), d = { maskTextSelector: h, unmaskTextSelector: l, maskInputSelector: h, unmaskInputSelector: l, blockSelector: gs(n, [".sentry-block", "[data-sentry-block]", 'base[href="/"]'], s, a), unblockSelector: gs(i, [".sentry-unblock", "[data-sentry-unblock]"]), ignoreSelector: gs(r, [".sentry-ignore", "[data-sentry-ignore]", 'input[type="file"]'], u) }; return s instanceof RegExp && (d.blockClass = s), o instanceof RegExp && (d.maskTextClass = o), d } function ws() { return "undefined" != typeof window && !0 } const vs = 'img,image,svg,video,object,picture,embed,map,audio,link[rel="icon"],link[rel="apple-touch-icon"]'; let ks = !1; class Ss { static __initStatic() { this.id = "Replay" } __init() { this.name = Ss.id } constructor({ flushMinDelay: t = 5e3, flushMaxDelay: e = 5500, stickySession: n = !0, useCompression: i = !0, _experiments: r = {}, sessionSampleRate: s, errorSampleRate: a, maskAllText: o = !0, maskAllInputs: c = !0, blockAllMedia: u = !0, mask: h = [], unmask: l = [], block: d = [], unblock: f = [], ignore: p = [], maskFn: m, blockClass: _, blockSelector: y, maskInputOptions: g, maskTextClass: b, maskTextSelector: w, ignoreClass: v } = {}) { if (Ss.prototype.__init.call(this), this.fe = { maskAllInputs: c, maskAllText: o, maskInputOptions: { ...g || {}, password: !0 }, maskTextFn: m, maskInputFn: m, ...bs({ mask: h, unmask: l, block: d, unblock: f, ignore: p, blockClass: _, blockSelector: y, maskTextClass: b, maskTextSelector: w, ignoreClass: v }), slimDOMOptions: "all", inlineStylesheet: !0, inlineImages: !1, collectFonts: !0 }, this.Ne = { flushMinDelay: t, flushMaxDelay: e, stickySession: n, sessionSampleRate: s, errorSampleRate: a, useCompression: i, blockAllMedia: u, _experiments: r }, "number" == typeof s && (console.warn(`[Replay] You are passing \`sessionSampleRate\` to the Replay integration.\nThis option is deprecated and will be removed soon.\nInstead, configure \`replaysSessionSampleRate\` directly in the SDK init options, e.g.:\nSentry.init({ replaysSessionSampleRate: ${s} })`), this.Ne.sessionSampleRate = s), "number" == typeof a && (console.warn(`[Replay] You are passing \`errorSampleRate\` to the Replay integration.\nThis option is deprecated and will be removed soon.\nInstead, configure \`replaysOnErrorSampleRate\` directly in the SDK init options, e.g.:\nSentry.init({ replaysOnErrorSampleRate: ${a} })`), this.Ne.errorSampleRate = a), this.Ne.blockAllMedia && (this.fe.blockSelector = this.fe.blockSelector ? `${this.fe.blockSelector},${vs}` : vs), this.Fe && ws()) throw new Error("Multiple Sentry Session Replay instances are not supported"); this.Fe = !0 } get Fe() { return ks } set Fe(t) { ks = t } setupOnce() { ws() && (this.je(), setTimeout((() => this.start()))) } start() { this._replay && this._replay.start() } stop() { this._replay && this._replay.stop() } flush() { if (this._replay && this._replay.isEnabled()) return this._replay.flushImmediate() } getReplayId() { if (this._replay && this._replay.isEnabled()) return this._replay.getSessionId() } je() { const t = function (t) { const e = se().getClient(), n = e && e.getOptions(), i = { sessionSampleRate: 0, errorSampleRate: 0, ...F(t) }; if (!n) return console.warn("SDK client is not available."), i; null == t.sessionSampleRate && null == t.errorSampleRate && null == n.replaysSessionSampleRate && null == n.replaysOnErrorSampleRate && console.warn("Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set."); "number" == typeof n.replaysSessionSampleRate && (i.sessionSampleRate = n.replaysSessionSampleRate); "number" == typeof n.replaysOnErrorSampleRate && (i.errorSampleRate = n.replaysOnErrorSampleRate); return i }(this.Ne); this._replay = new ys({ options: t, recordingOptions: this.fe }) } } Ss.__initStatic(); const xs = p; let Ts = 0; function Es() { return Ts > 0 } function Is() { Ts++, setTimeout((() => { Ts-- })) } function As(t, e = {}, n) { if ("function" != typeof t) return t; try { const e = t.__sentry_wrapped__; if (e) return e; if (D(t)) return t } catch (e) { return t } const sentryWrapped = function () { const i = Array.prototype.slice.call(arguments); try { n && "function" == typeof n && n.apply(this, arguments); const r = i.map((t => As(t, e))); return t.apply(this, r) } catch (t) { throw Is(), Te((n => { n.addEventProcessor((t => (e.mechanism && (lt(t, void 0, void 0), dt(t, e.mechanism)), t.extra = { ...t.extra, arguments: i }, t))), captureException(t) })), t } }; try { for (const e in t) Object.prototype.hasOwnProperty.call(t, e) && (sentryWrapped[e] = t[e]) } catch (t) { } z(sentryWrapped, t), R(t, "__sentry_wrapped__", sentryWrapped); try { Object.getOwnPropertyDescriptor(sentryWrapped, "name").configurable && Object.defineProperty(sentryWrapped, "name", { get: () => t.name }) } catch (t) { } return sentryWrapped } function Cs(t, e) { const n = Rs(t, e), i = { type: e && e.name, value: Ds(e) }; return n.length && (i.stacktrace = { frames: n }), void 0 === i.type && "" === i.value && (i.value = "Unrecoverable error caught"), i } function Os(t, e) { return { exception: { values: [Cs(t, e)] } } } function Rs(t, e) { const n = e.stacktrace || e.stack || "", i = function (t) { if (t) { if ("number" == typeof t.framesToPop) return t.framesToPop; if (zs.test(t.message)) return 1 } return 0 }(e); try { return t(n, i) } catch (t) { } return [] } const zs = /Minified React error #\d+;/i; function Ds(t) { const e = t && t.message; return e ? e.error && "string" == typeof e.error.message ? e.error.message : e : "No error message" } function Ls(t, e, n, i) { const r = $s(t, e, n && n.syntheticException || void 0, i); return dt(r), r.level = "error", n && n.event_id && (r.event_id = n.event_id), bt(r) } function Ms(t, e, n = "info", i, r) { const s = Ns(t, e, i && i.syntheticException || void 0, r); return s.level = n, i && i.event_id && (s.event_id = i.event_id), bt(s) } function $s(t, e, a, o, h) { let l; if (r(e) && e.error) { return Os(t, e.error) } if (s(e) || i(e, "DOMException")) { const n = e; if ("stack" in e) l = Os(t, e); else { const e = n.name || (s(n) ? "DOMError" : "DOMException"), i = n.message ? `${e}: ${n.message}` : e; l = Ns(t, i, a, o), lt(l, i) } return "code" in n && (l.tags = { ...l.tags, "DOMException.code": `${n.code}` }), l } if (n(e)) return Os(t, e); if (c(e) || u(e)) { return l = function (t, e, n, i) { const r = se().getClient(), s = r && r.getOptions().normalizeDepth, a = { exception: { values: [{ type: u(e) ? e.constructor.name : i ? "UnhandledRejection" : "Error", value: `Non-Error ${i ? "promise rejection" : "exception"} captured with keys: ${N(e)}` }] }, extra: { __serialized__: _t(e, s) } }; if (n) { const e = Rs(t, n); e.length && (a.exception.values[0].stacktrace = { frames: e }) } return a }(t, e, a, h), dt(l, { synthetic: !0 }), l } return l = Ns(t, e, a, o), lt(l, `${e}`, void 0), dt(l, { synthetic: !0 }), l } function Ns(t, e, n, i) { const r = { message: e }; if (i && n) { const i = Rs(t, n); i.length && (r.exception = { values: [{ value: e, stacktrace: { frames: i } }] }) } return r } const Fs = 1024, js = "Breadcrumbs"; class Us { static __initStatic() { this.id = js } __init() { this.name = Us.id } constructor(t) { Us.prototype.__init.call(this), this.options = { console: !0, dom: !0, fetch: !0, history: !0, sentry: !0, xhr: !0, ...t } } setupOnce() { this.options.console && V("console", Bs), this.options.dom && V("dom", function (t) { function e(e) { let n, i = "object" == typeof t ? t.serializeAttribute : void 0, r = "object" == typeof t && "number" == typeof t.maxStringLength ? t.maxStringLength : void 0; r && r > Fs && (r = Fs), "string" == typeof i && (i = [i]); try { const t = e.event; n = function (t) { return t && !!t.target }(t) ? g(t.target, { keyAttrs: i, maxStringLength: r }) : g(t, { keyAttrs: i, maxStringLength: r }) } catch (t) { n = "<unknown>" } 0 !== n.length && se().addBreadcrumb({ category: `ui.${e.name}`, message: n }, { event: e.event, name: e.name, global: e.global }) } return e }(this.options.dom)), this.options.xhr && V("xhr", Hs), this.options.fetch && V("fetch", Zs), this.options.history && V("history", Ps) } addSentryBreadcrumb(t) { this.options.sentry && se().addBreadcrumb({ category: "sentry." + ("transaction" === t.type ? "transaction" : "event"), event_id: t.event_id, level: t.level, message: ht(t) }, { event: t }) } } function Bs(t) { for (let e = 0; e < t.args.length; e++)if ("ref=Ref<" === t.args[e]) { t.args[e + 1] = "viewRef"; break } const e = { category: "console", data: { arguments: t.args, logger: "console" }, level: (n = t.level, "warn" === n ? "warning" : xt.includes(n) ? n : "log"), message: I(t.args, " ") }; var n; if ("assert" === t.level) { if (!1 !== t.args[0]) return; e.message = `Assertion failed: ${I(t.args.slice(1), " ") || "console.assert"}`, e.data.arguments = t.args.slice(1) } se().addBreadcrumb(e, { input: t.args, level: t.level }) } function Hs(t) { const { startTimestamp: e, endTimestamp: n } = t, i = t.xhr.__sentry_xhr_v2__; if (!e || !n || !i) return; const { method: r, url: s, status_code: a, body: o } = i, c = { method: r, url: s, status_code: a }, u = { xhr: t.xhr, input: o, startTimestamp: e, endTimestamp: n }; se().addBreadcrumb({ category: "xhr", data: c, type: "http" }, u) } function Zs(t) { const { startTimestamp: e, endTimestamp: n } = t; if (n && (!t.fetchData.url.match(/sentry_key/) || "POST" !== t.fetchData.method)) if (t.error) { const i = t.fetchData, r = { data: t.error, input: t.args, startTimestamp: e, endTimestamp: n }; se().addBreadcrumb({ category: "fetch", data: i, level: "error", type: "http" }, r) } else { const i = { ...t.fetchData, status_code: t.response && t.response.status }, r = { input: t.args, response: t.response, startTimestamp: e, endTimestamp: n }; se().addBreadcrumb({ category: "fetch", data: i, type: "http" }, r) } } function Ps(t) { let e = t.from, n = t.to; const i = St(xs.location.href); let r = St(e); const s = St(n); r.path || (r = i), i.protocol === s.protocol && i.host === s.host && (n = s.relative), i.protocol === r.protocol && i.host === r.host && (e = r.relative), se().addBreadcrumb({ category: "navigation", data: { from: e, to: n } }) } function qs(t, { metadata: e, tunnel: n, dsn: i }) { const r = { event_id: t.event_id, sent_at: (new Date).toISOString(), ...e && e.sdk && { sdk: { name: e.sdk.name, version: e.sdk.version } }, ...!!n && !!i && { dsn: k(i) } }, s = function (t) { return [{ type: "user_report" }, t] }(t); return Dt(r, [s]) } Us.__initStatic(); class Ws extends Le { constructor(t) { const e = xs.SENTRY_SDK_SOURCE || "npm"; t.vt = t.vt || {}, t.vt.sdk = t.vt.sdk || { name: "sentry.javascript.browser", packages: [{ name: `${e}:@sentry/browser`, version: je }], version: je }, super(t), t.sendClientReports && xs.document && xs.document.addEventListener("visibilitychange", (() => { "hidden" === xs.document.visibilityState && this.Ue() })) } eventFromException(t, e) { return Ls(this.It.stackParser, t, e, this.It.attachStacktrace) } eventFromMessage(t, e = "info", n) { return Ms(this.It.stackParser, t, e, n, this.It.attachStacktrace) } sendEvent(t, e) { const n = this.getIntegrationById(js); n && n.addSentryBreadcrumb && n.addSentryBreadcrumb(t), super.sendEvent(t, e) } captureUserFeedback(t) { if (!this.zt()) return; const e = qs(t, { metadata: this.getSdkMetadata(), dsn: this.getDsn(), tunnel: this.getOptions().tunnel }); this.Lt(e) } $t(t, e, n) { return t.platform = t.platform || "javascript", super.$t(t, e, n) } Ue() { const t = this.Ft(); if (0 === t.length) return; if (!this.At) return; const e = (n = t, Dt((i = this.It.tunnel && k(this.At)) ? { dsn: i } : {}, [[{ type: "client_report" }, { timestamp: r || Ct(), discarded_events: n }]])); var n, i, r; this.Lt(e) } } let Xs; function Gs(t, e = function () { if (Xs) return Xs; if (W(xs.fetch)) return Xs = xs.fetch.bind(xs); const t = xs.document; let e = xs.fetch; if (t && "function" == typeof t.createElement) try { const n = t.createElement("iframe"); n.hidden = !0, t.head.appendChild(n); const i = n.contentWindow; i && i.fetch && (e = i.fetch), t.head.removeChild(n) } catch (t) { } return Xs = e.bind(xs) }()) { let n = 0, i = 0; return Ne(t, (function (r) { const s = r.body.length; n += s, i++; const a = { body: r.body, method: "POST", referrerPolicy: "origin", headers: t.headers, keepalive: n <= 6e4 && i < 15, ...t.fetchOptions }; try { return e(t.url, a).then((t => (n -= s, i--, { statusCode: t.status, headers: { "x-sentry-rate-limits": t.headers.get("X-Sentry-Rate-Limits"), "retry-after": t.headers.get("Retry-After") } }))) } catch (t) { return Xs = void 0, n -= s, i--, wt(t) } })) } function Js(t) { return Ne(t, (function (e) { return new vt(((n, i) => { const r = new XMLHttpRequest; r.onerror = i, r.onreadystatechange = () => { 4 === r.readyState && n({ statusCode: r.status, headers: { "x-sentry-rate-limits": r.getResponseHeader("X-Sentry-Rate-Limits"), "retry-after": r.getResponseHeader("Retry-After") } }) }, r.open("POST", t.url); for (const e in t.headers) Object.prototype.hasOwnProperty.call(t.headers, e) && r.setRequestHeader(e, t.headers[e]); r.send(e.body) })) })) } const Ks = "?"; function Ys(t, e, n, i) { const r = { filename: t, function: e, in_app: !0 }; return void 0 !== n && (r.lineno = n), void 0 !== i && (r.colno = i), r } const Vs = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, Qs = /\((\S*)(?::(\d+))(?::(\d+))\)/, ta = [30, t => { const e = Vs.exec(t); if (e) { if (e[2] && 0 === e[2].indexOf("eval")) { const t = Qs.exec(e[2]); t && (e[2] = t[1], e[3] = t[2], e[4] = t[3]) } const [t, n] = da(e[1] || Ks, e[2]); return Ys(n, t, e[3] ? +e[3] : void 0, e[4] ? +e[4] : void 0) } }], ea = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i, na = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i, ia = [50, t => { const e = ea.exec(t); if (e) { if (e[3] && e[3].indexOf(" > eval") > -1) { const t = na.exec(e[3]); t && (e[1] = e[1] || "eval", e[3] = t[1], e[4] = t[2], e[5] = "") } let t = e[3], n = e[1] || Ks; return [n, t] = da(n, t), Ys(t, n, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0) } }], ra = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i, sa = [40, t => { const e = ra.exec(t); return e ? Ys(e[2], e[1] || Ks, +e[3], e[4] ? +e[4] : void 0) : void 0 }], aa = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i, oa = [10, t => { const e = aa.exec(t); return e ? Ys(e[2], e[3] || Ks, +e[1]) : void 0 }], ca = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\(.*\))? in (.*):\s*$/i, ua = [20, t => { const e = ca.exec(t); return e ? Ys(e[5], e[3] || e[4] || Ks, +e[1], +e[2]) : void 0 }], ha = [ta, ia, sa], la = B(...ha), da = (t, e) => { const n = -1 !== t.indexOf("safari-extension"), i = -1 !== t.indexOf("safari-web-extension"); return n || i ? [-1 !== t.indexOf("@") ? t.split("@")[0] : Ks, n ? `safari-extension:${e}` : `safari-web-extension:${e}`] : [t, e] }; class fa { static __initStatic() { this.id = "GlobalHandlers" } __init() { this.name = fa.id } __init2() { this.Be = { onerror: pa, onunhandledrejection: ma } } constructor(t) { fa.prototype.__init.call(this), fa.prototype.__init2.call(this), this.It = { onerror: !0, onunhandledrejection: !0, ...t } } setupOnce() { Error.stackTraceLimit = 50; const t = this.It; for (const e in t) { const n = this.Be[e]; n && t[e] && (n(), this.Be[e] = void 0) } } } function pa() { V("error", (t => { const [e, n, i] = ga(); if (!e.getIntegration(fa)) return; const { msg: s, url: o, line: c, column: u, error: h } = t; if (Es() || h && h.__sentry_own_request__) return; const l = void 0 === h && a(s) ? function (t, e, n, i) { const s = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i; let a = r(t) ? t.message : t, o = "Error"; const c = a.match(s); c && (o = c[1], a = c[2]); return _a({ exception: { values: [{ type: o, value: a }] } }, e, n, i) }(s, o, c, u) : _a($s(n, h || s, void 0, i, !1), o, c, u); l.level = "error", ya(e, h, l, "onerror") })) } function ma() { V("unhandledrejection", (t => { const [e, n, i] = ga(); if (!e.getIntegration(fa)) return; let r = t; try { "reason" in t ? r = t.reason : "detail" in t && "reason" in t.detail && (r = t.detail.reason) } catch (t) { } if (Es() || r && r.__sentry_own_request__) return !0; const s = o(r) ? { exception: { values: [{ type: "UnhandledRejection", value: `Non-Error promise rejection captured with value: ${String(r)}` }] } } : $s(n, r, void 0, i, !0); s.level = "error", ya(e, r, s, "onunhandledrejection") })) } function _a(t, e, n, i) { const r = t.exception = t.exception || {}, s = r.values = r.values || [], o = s[0] = s[0] || {}, c = o.stacktrace = o.stacktrace || {}, u = c.frames = c.frames || [], h = isNaN(parseInt(i, 10)) ? void 0 : i, l = isNaN(parseInt(n, 10)) ? void 0 : n, d = a(e) && e.length > 0 ? e : function () { try { return y.document.location.href } catch (t) { return "" } }(); return 0 === u.length && u.push({ colno: h, filename: d, function: "?", in_app: !0, lineno: l }), t } function ya(t, e, n, i) { dt(n, { handled: !1, type: i }), t.captureEvent(n, { originalException: e }) } function ga() { const t = se(), e = t.getClient(), n = e && e.getOptions() || { stackParser: () => [], attachStacktrace: !1 }; return [t, n.stackParser, n.attachStacktrace] } fa.__initStatic(); const ba = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"]; class wa { static __initStatic() { this.id = "TryCatch" } __init() { this.name = wa.id } constructor(t) { wa.prototype.__init.call(this), this.It = { XMLHttpRequest: !0, eventTarget: !0, requestAnimationFrame: !0, setInterval: !0, setTimeout: !0, ...t } } setupOnce() { this.It.setTimeout && O(xs, "setTimeout", va), this.It.setInterval && O(xs, "setInterval", va), this.It.requestAnimationFrame && O(xs, "requestAnimationFrame", ka), this.It.XMLHttpRequest && "XMLHttpRequest" in xs && O(XMLHttpRequest.prototype, "send", Sa); const t = this.It.eventTarget; if (t) { (Array.isArray(t) ? t : ba).forEach(xa) } } } function va(t) { return function (...e) { const n = e[0]; return e[0] = As(n, { mechanism: { data: { function: Z(t) }, handled: !0, type: "instrument" } }), t.apply(this, e) } } function ka(t) { return function (e) { return t.apply(this, [As(e, { mechanism: { data: { function: "requestAnimationFrame", handler: Z(t) }, handled: !0, type: "instrument" } })]) } } function Sa(t) { return function (...e) { const n = this; return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((t => { t in n && "function" == typeof n[t] && O(n, t, (function (e) { const n = { mechanism: { data: { function: t, handler: Z(e) }, handled: !0, type: "instrument" } }, i = D(e); return i && (n.mechanism.data.handler = Z(i)), As(e, n) })) })), t.apply(this, e) } } function xa(t) { const e = xs, n = e[t] && e[t].prototype; n && n.hasOwnProperty && n.hasOwnProperty("addEventListener") && (O(n, "addEventListener", (function (e) { return function (n, i, r) { try { "function" == typeof i.handleEvent && (i.handleEvent = As(i.handleEvent, { mechanism: { data: { function: "handleEvent", handler: Z(i), target: t }, handled: !0, type: "instrument" } })) } catch (t) { } return e.apply(this, [n, As(i, { mechanism: { data: { function: "addEventListener", handler: Z(i), target: t }, handled: !0, type: "instrument" } }), r]) } })), O(n, "removeEventListener", (function (t) { return function (e, n, i) { const r = n; try { const n = r && r.__sentry_wrapped__; n && t.call(this, e, n, i) } catch (t) { } return t.call(this, e, r, i) } }))) } wa.__initStatic(); class Ta { static __initStatic() { this.id = "LinkedErrors" } __init() { this.name = Ta.id } constructor(t = {}) { Ta.prototype.__init.call(this), this.He = t.key || "cause", this.Ze = t.limit || 5 } setupOnce() { const t = se().getClient(); t && te(((e, n) => { const i = se().getIntegration(Ta); return i ? function (t, e, n, i, r) { if (!(i.exception && i.exception.values && r && d(r.originalException, Error))) return i; const s = Ea(t, n, r.originalException, e); return i.exception.values = [...s, ...i.exception.values], i }(t.getOptions().stackParser, i.He, i.Ze, e, n) : e })) } } function Ea(t, e, n, i, r = []) { if (!d(n[i], Error) || r.length + 1 >= e) return r; const s = Cs(t, n[i]); return Ea(t, e, n[i], i, [s, ...r]) } Ta.__initStatic(); class Ia { constructor() { Ia.prototype.__init.call(this) } static __initStatic() { this.id = "HttpContext" } __init() { this.name = Ia.id } setupOnce() { te((t => { if (se().getIntegration(Ia)) { if (!xs.navigator && !xs.location && !xs.document) return t; const e = t.request && t.request.url || xs.location && xs.location.href, { referrer: n } = xs.document || {}, { userAgent: i } = xs.navigator || {}, r = { ...t.request && t.request.headers, ...n && { Referer: n }, ...i && { "User-Agent": i } }, s = { ...t.request, ...e && { url: e }, headers: r }; return { ...t, request: s } } return t })) } } Ia.__initStatic(); class Aa { constructor() { Aa.prototype.__init.call(this) } static __initStatic() { this.id = "Dedupe" } __init() { this.name = Aa.id } setupOnce(t, e) { const n = t => { if (t.type) return t; const n = e().getIntegration(Aa); if (n) { try { if (function (t, e) { if (!e) return !1; if (function (t, e) { const n = t.message, i = e.message; if (!n && !i) return !1; if (n && !i || !n && i) return !1; if (n !== i) return !1; if (!Oa(t, e)) return !1; if (!Ca(t, e)) return !1; return !0 }(t, e)) return !0; if (function (t, e) { const n = Ra(e), i = Ra(t); if (!n || !i) return !1; if (n.type !== i.type || n.value !== i.value) return !1; if (!Oa(t, e)) return !1; if (!Ca(t, e)) return !1; return !0 }(t, e)) return !0; return !1 }(t, n.Pe)) return null } catch (e) { return n.Pe = t } return n.Pe = t } return t }; n.id = this.name, t(n) } } function Ca(t, e) { let n = za(t), i = za(e); if (!n && !i) return !0; if (n && !i || !n && i) return !1; if (n = n, i = i, i.length !== n.length) return !1; for (let t = 0; t < i.length; t++) { const e = i[t], r = n[t]; if (e.filename !== r.filename || e.lineno !== r.lineno || e.colno !== r.colno || e.function !== r.function) return !1 } return !0 } function Oa(t, e) { let n = t.fingerprint, i = e.fingerprint; if (!n && !i) return !0; if (n && !i || !n && i) return !1; n = n, i = i; try { return !(n.join("") !== i.join("")) } catch (t) { return !1 } } function Ra(t) { return t.exception && t.exception.values && t.exception.values[0] } function za(t) { const e = t.exception; if (e) try { return e.values[0].stacktrace.frames } catch (t) { return } } Aa.__initStatic(); var Da = Object.freeze({ __proto__: null, GlobalHandlers: fa, TryCatch: wa, Breadcrumbs: Us, LinkedErrors: Ta, HttpContext: Ia, Dedupe: Aa }); const La = [new Ze, new Be, new wa, new Us, new fa, new Ta, new Aa, new Ia]; function Ma(t) { t.startSession({ ignoreDuration: !0 }), t.captureSession() } let $a = {}; xs.Sentry && xs.Sentry.Integrations && ($a = xs.Sentry.Integrations); const Na = { ...$a, ...qe, ...Da }; return Na.Replay = Ss, Na.BrowserTracing = gn, wn(), t.Breadcrumbs = Us, t.BrowserClient = Ws, t.BrowserTracing = gn, t.Dedupe = Aa, t.FunctionToString = Be, t.GlobalHandlers = fa, t.HttpContext = Ia, t.Hub = ne, t.InboundFilters = Ze, t.Integrations = Na, t.LinkedErrors = Ta, t.Replay = Ss, t.SDK_VERSION = je, t.Scope = Vt, t.Span = fe, t.TryCatch = wa, t.WINDOW = xs, t.addBreadcrumb = function (t) { se().addBreadcrumb(t) }, t.addExtensionMethods = wn, t.addGlobalEventProcessor = te, t.captureEvent = function (t, e) { return se().captureEvent(t, e) }, t.captureException = captureException, t.captureMessage = function (t, e) { const n = "string" == typeof e ? e : void 0, i = "string" != typeof e ? { captureContext: e } : void 0; return se().captureMessage(t, n, i) }, t.captureUserFeedback = function (t) { const e = se().getClient(); e && e.captureUserFeedback(t) }, t.chromeStackLineParser = ta, t.close = function (t) { const e = se().getClient(); return e ? e.close(t) : bt(!1) }, t.configureScope = function (t) { se().configureScope(t) }, t.createTransport = Ne, t.createUserFeedbackEnvelope = qs, t.defaultIntegrations = La, t.defaultStackLineParsers = ha, t.defaultStackParser = la, t.eventFromException = Ls, t.eventFromMessage = Ms, t.flush = function (t) { const e = se().getClient(); return e ? e.flush(t) : bt(!1) }, t.forceLoad = function () { }, t.geckoStackLineParser = ia, t.getCurrentHub = se, t.getHubFromCarrier = ae, t.init = function (t = {}) { void 0 === t.defaultIntegrations && (t.defaultIntegrations = La), void 0 === t.release && ("string" == typeof __SENTRY_RELEASE__ && (t.release = __SENTRY_RELEASE__), xs.SENTRY_RELEASE && xs.SENTRY_RELEASE.id && (t.release = xs.SENTRY_RELEASE.id)), void 0 === t.autoSessionTracking && (t.autoSessionTracking = !0), void 0 === t.sendClientReports && (t.sendClientReports = !0); const e = { ...t, stackParser: (n = t.stackParser || la, Array.isArray(n) ? B(...n) : n), integrations: Oe(t), transport: t.transport || (q() ? Gs : Js) }; var n; !function (t, e) { !0 === e.debug && console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle."); const n = se(); n.getScope().update(e.initialScope); const i = new t(e); n.bindClient(i) }(Ws, e), t.autoSessionTracking && function () { if (void 0 === xs.document) return; const t = se(); if (!t.captureSession) return; Ma(t), V("history", (({ from: t, to: e }) => { void 0 !== t && t !== e && Ma(se()) })) }() }, t.lastEventId = function () { return se().lastEventId() }, t.makeFetchTransport = Gs, t.makeMain = re, t.makeXHRTransport = Js, t.onLoad = function (t) { t() }, t.opera10StackLineParser = oa, t.opera11StackLineParser = ua, t.setContext = xe, t.setExtra = function (t, e) { se().setExtra(t, e) }, t.setExtras = function (t) { se().setExtras(t) }, t.setTag = function (t, e) { se().setTag(t, e) }, t.setTags = function (t) { se().setTags(t) }, t.setUser = function (t) { se().setUser(t) }, t.showReportDialog = function (t = {}, e = se()) { if (!xs.document) return; const { client: n, scope: i } = e.getStackTop(), r = t.dsn || n && n.getDsn(); if (!r) return; i && (t.user = { ...i.getUser(), ...t.user }), t.eventId || (t.eventId = e.lastEventId()); const s = xs.document.createElement("script"); s.async = !0, s.src = function (t, e) { const n = x(t), i = `${Ee(n)}embed/error-page/`; let r = `dsn=${k(n)}`; for (const t in e) if ("dsn" !== t) if ("user" === t) { const t = e.user; if (!t) continue; t.name && (r += `&name=${encodeURIComponent(t.name)}`), t.email && (r += `&email=${encodeURIComponent(t.email)}`) } else r += `&${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`; return `${i}?${r}` }(r, t), t.onLoad && (s.onload = t.onLoad); const a = xs.document.head || xs.document.body; a && a.appendChild(s) }, t.startTransaction = function (t, e) { return se().startTransaction({ ...t }, e) }, t.winjsStackLineParser = sa, t.withScope = Te, t.wrap = function (t) { return As(t)() }, t }({});
